#include "../Shaders/PhotonerCommon.cginc"
#include "../Shaders/Random.cginc"
#include "../Shaders/SimulationCommon.cginc"

#pragma multi_compile __ BILINEAR_PHOTON_DISTRIBUTION
#pragma multi_compile __ FINALIZE_OUTSCATTER_DENSITY
#pragma multi_compile __ SKIP_ACCUMULATION

#pragma kernel Simulate_DefaultLight
#pragma kernel Simulate_PointLight
#pragma kernel Simulate_SpotLight
#pragma kernel Simulate_LaserLight
#pragma kernel Simulate_AmbientLight
#pragma kernel Simulate_FieldLight
#pragma kernel Simulate_DirectionalLight
#pragma kernel ConvertToHDR

#line 18

RWStructuredBuffer<uint4> g_rand;
RWStructuredBuffer<uint> g_write_counter;
RWStructuredBuffer<uint> g_needs_accumulation;
RWTexture2D<uint> g_output_raw;

uint g_bounces;
uint g_threadgroup_count;
float g_integration_interval;
float g_integration_interval_squared;

// Light Emission Data
Texture2D<float4> g_lightFieldTexture;

float4x4 g_lightToTarget;
float3 g_lightEnergy;
float g_lightEmissionOutscatter;
float2 g_directionalLightDirection;


// HDR Conversion
float g_hdr_scale;
float g_batch_count_inv;
RWTexture2D<float4> g_output_hdr;
RWTexture2D<float4> g_accumulated_output_hdr;

// Write Counter
groupshared uint shared_write_counter;
groupshared int shared_live_threads;
groupshared bool shared_needs_accumulation;

void ClearPhoton_Indexed(int2 pixel) {
    pixel.x *= 3;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
}

uint3 ReadPhoton_Indexed(uint2 pixel) {
    pixel.x *= 3;
    return uint3(
        g_output_raw[pixel],
        g_output_raw[pixel + 1],
        g_output_raw[pixel + 2]
    );
}

void WritePhoton_Indexed(int2 pixel, float3 energy, bool suppressPhoton=false) {
    const uint EnergyMax = (1 << 31);

    if(!suppressPhoton) {
        InterlockedAdd(shared_write_counter, 1);
    }

    pixel.x *= 3;
    uint3 rgb;
    InterlockedAdd(g_output_raw[pixel], energy.r, rgb.r);
    InterlockedAdd(g_output_raw[pixel + 1], energy.g, rgb.g);
    InterlockedAdd(g_output_raw[pixel + 2], energy.b, rgb.b);
    
#if !SKIP_ACCUMULATION
    if(any(rgb > EnergyMax)) {
        shared_needs_accumulation = true;
    }
#endif
}

void WritePhoton_Bilinear(float2 location, float3 energy, bool suppressPhoton=false) {
    if(any(location < 0)) return;

    float2 pixel = location - 0.5f;
    int2 pixelFloor = (int2)floor(pixel);
    float2 pixelFrac = pixel - pixelFloor;

    WritePhoton_Indexed(pixelFloor, energy * (1 - pixelFrac.x) * (1 - pixelFrac.y), suppressPhoton);
    WritePhoton_Indexed(pixelFloor + int2(1, 0), energy * pixelFrac.x * (1 - pixelFrac.y), true /*suppressPhoton*/);
    WritePhoton_Indexed(pixelFloor + int2(0, 1), energy * (1 - pixelFrac.x) * pixelFrac.y, true /*suppressPhoton*/);
    WritePhoton_Indexed(pixelFloor + int2(1, 1), energy * pixelFrac.x * pixelFrac.y, true /*suppressPhoton*/);
}

void WritePhoton(float2 location, float3 energy, bool suppressPhoton=false) {
#if BILINEAR_PHOTON_DISTRIBUTION
    WritePhoton_Bilinear(location, energy, suppressPhoton);
#else
    WritePhoton_Indexed(location, energy, suppressPhoton);
#endif
}

struct ForwardMonteCarlo : BaseContext, IMonteCarloMethod
{
    bool searchingPhase;
    float transmitPotential;
    float quantumScale;
    float currentSample;
    float hitIntensity;
    float uSampleTarget;
    float transmissibility;
    float uSampleRandomOffset;

    float tested_transmissibility;
    float tested_u;

    void WriteSample(float3 energy, float2 location, float2 uv)
    {
        float4 normal_alignment = g_normalAlignment.SampleLevel(samplerg_normalAlignment, uv, 0);
        float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, uv, 0).rgb;

        float outScatterDensity = g_integration_interval_squared * transmissibility;
        WritePhoton(location, energy * outScatterDensity, false);
    }

    void Init(uint4 seed)
    {
        Init_BaseContext(seed);
        searchingPhase = true;

        hitIntensity = 0;
        transmissibility = 1;

        transmitPotential = 1;
        quantumScale = 1;
        currentSample = 0;
        uSampleTarget = 0;
        uSampleRandomOffset = rand.Next();
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        currentSample = 0;
        uSampleTarget = rand.Next() * g_integration_interval;
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        if(searchingPhase) {
            return tested_u > ctx.uEscape; 
        } else {
            float minimumTransmissibility = ctx.transmissibilityNext.y;
            return ctx.uHitNext > ctx.uEscape || minimumTransmissibility * transmissibility < transmitPotential;
        }
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        while(searchingPhase && tested_u > uSampleTarget) {
            currentSample += 1;
            uSampleRandomOffset = rand.Next();

            // note: ctx.testUV is a slightly different location than uSampleTarget points. Doesn't seem to impact quality,
            // but it seems to be simpler math to do it this way. Revisit if odd blurriness or lines are noticed.
            WriteSample(ctx.photon.Energy, ctx.photon.Origin + ctx.photon.Direction * uSampleTarget, ctx.testUV);
            uSampleTarget = (currentSample + uSampleRandomOffset) * g_integration_interval; 
        }

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return true; //ctx.uHitNext < ctx.uEscape && transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        if(!searchingPhase) {
            ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / (log2(tested_transmissibility.x) - 1e-5);
        } else {
            ctx.uHitCurrent = 0;
        }
        return true;//probability > 1e-7;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        if(!searchingPhase) {
            //float3 important_direction = ScatterImportanceLobed(ctx.photon.Origin);
            float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.testUV, ctx.photon.Direction);

            ctx.photon.Energy *= albedo * quantumScale * important_direction.z;
            ctx.photon.Direction = important_direction.xy;
            ctx.photon.Origin += ctx.photon.Direction;

            if(important_direction.w < 0.5) {
                searchingPhase = true;
            } else { // otherwise it's a false bounce. Return to propagating.
                transmissibility /= tested_transmissibility;
            }
        } else {
            float u = rand.Next(transmissibility, 1);
            transmitPotential = u;
            quantumScale = 1-transmissibility;
            searchingPhase = false;
        }
        return searchingPhase;
    }

    Ray EmitPointLight() {
        Ray emitted;
        
        float2 pos = rand.NextCircle();
        
        emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
        
        //float3 important_direction = ScatterImportanceLobed(emitted.Origin);
        float3 important_direction = { rand.NextDirection(), 1.0 / (2 * PI)};
        emitted.Direction = important_direction.xy;
        emitted.Energy = g_lightEnergy * important_direction.z;

        return emitted;
    } 

    Ray EmitSpotLight() {
        Ray emitted;

        emitted.Origin = mul(float4(rand.Next()-0.5, rand.Next()-0.5, 0, 1), g_lightToTarget).xy;
        emitted.Direction = normalize(mul(float4(2*rand.Next()-1, -1, 0, 0), g_lightToTarget).xy);
        emitted.Energy = g_lightEnergy;

        return emitted;
    }

    Ray EmitLaserLight() {
        Ray emitted;

        emitted.Origin = mul(float4(rand.Next()-0.5, rand.Next(), 0, 1), g_lightToTarget).xy;
        emitted.Direction = normalize(mul(float4(0,-1,0,0), g_lightToTarget).xy);
        emitted.Energy = g_lightEnergy;

        return emitted;
    }

    Ray EmitAmbientLight() {
        Ray emitted;

        float2 nOrigin = rand.Next2();
        emitted.Origin = nOrigin * targetSize;
        emitted.Direction = normalize(rand.NextDirection() - (nOrigin * 2 - 1) / 1.44);
        emitted.Energy = g_lightEnergy;

        return emitted;
    }

    Ray EmitFieldLight() {
        Ray emitted;

        float2 uv = rand.Next2();
        float2 pos = uv*2-1;

        float2 _ddx = ddx(g_lightToTarget._m00_m01);
        float2 _ddy = ddy(g_lightToTarget._m10_m11);

        emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
        emitted.Direction = rand.NextDirection();
        float4 texValue = g_lightFieldTexture.SampleGrad(sampler_linear_clamp, uv, _ddx, _ddy);
        texValue.rgb *= (texValue.a - 0.08);
        emitted.Energy = g_lightEnergy * texValue.rgb;

        return emitted;
    }

    Ray EmitDirectionalLight() {
        Ray emitted;

        float2 perp = g_directionalLightDirection.yx;
        perp.y *= -1;
        emitted.Direction = g_directionalLightDirection;

        emitted.Origin = 0.5 - g_directionalLightDirection + perp * (rand.Next() * 1.415 - 0.7075);
        emitted.Origin *= targetSize;
        emitted.Energy = g_lightEnergy;

        return emitted;
    }

    Ray EmitDefaultLight() {
        Ray emitted;

        emitted.Origin = float2(rand.Next(), 0) * targetSize;
        emitted.Direction = float2(0,1);
        emitted.Energy = float3(0,1000,0);

        return emitted;
    }
};

ForwardMonteCarlo BeginSimulation(uint3 id, uint localID) {
    if(localID == 0) {
        shared_needs_accumulation = false;
        shared_write_counter = 0;
        shared_live_threads = uint3(NUMTHREADS_1D).x;
    }

    GroupMemoryBarrierWithGroupSync();

    ForwardMonteCarlo integrator;
    integrator.Init(g_rand[id.x]);
    return integrator;
}

void EndSimulation(uint3 id, inout ForwardMonteCarlo integrator, Ray photon) {
    Integrate(photon, g_bounces, integrator);
    g_rand[id.x] = integrator.rand.state;
    int previous_threads;
    InterlockedAdd(shared_live_threads, -1, previous_threads);
    if(previous_threads == 1) {
        uint global_write_counter;

        // Hacking in uint64_t
        InterlockedAdd(g_write_counter[0], shared_write_counter, global_write_counter);
        if(shared_write_counter > (0xFFFFFFFF - global_write_counter)) {
            InterlockedAdd(g_write_counter[1], 1);
        }

        if(shared_needs_accumulation) {
            g_needs_accumulation[0] = g_threadgroup_count;
        }
    }
}

#define SIMULATION_IMPLEMENTATION(lightType)                        \
[numthreads(NUMTHREADS_1D)] void Simulate_##lightType (             \
    uint3 id : SV_DispatchThreadID, uint localID : SV_GroupIndex) { \
    ForwardMonteCarlo integrator = BeginSimulation(id, localID);    \
    Ray photon = integrator.Emit##lightType();                      \
    EndSimulation(id, integrator, photon);                          \
}

SIMULATION_IMPLEMENTATION(DefaultLight)
SIMULATION_IMPLEMENTATION(PointLight)
SIMULATION_IMPLEMENTATION(SpotLight)
SIMULATION_IMPLEMENTATION(LaserLight)
SIMULATION_IMPLEMENTATION(AmbientLight)
SIMULATION_IMPLEMENTATION(FieldLight)
SIMULATION_IMPLEMENTATION(DirectionalLight)


[numthreads(NUMTHREADS_2D)]
void ConvertToHDR (uint3 id : SV_DispatchThreadID, uint2 localID : SV_GroupThreadID) {
    float outScatterDensity = 1;
    float3 albedo = g_albedo[id.xy].rgb;

#if FINALIZE_OUTSCATTER_DENSITY
    outScatterDensity *= (1 - g_transmissibility[id.xy].x);
#endif

    float3 cumulative = ReadPhoton_Indexed(id.xy) * g_hdr_scale;

#if !SKIP_ACCUMULATION
    cumulative += g_accumulated_output_hdr[id.xy].rgb;
    if(g_needs_accumulation[0] != 0) {
        ClearPhoton_Indexed(id.xy);
        g_accumulated_output_hdr[id.xy] = float4(cumulative, 0);

        if(localID.x == 0 && localID.y == 0) {
            InterlockedAdd(g_needs_accumulation[0], -1);
        }
    }
#endif

    g_output_hdr[id.xy] = float4(cumulative * albedo * g_batch_count_inv * outScatterDensity, 1);
}
