#include "../Shaders/RayTracing2DCommon.cginc"
#include "../Shaders/Noise2D.cginc"

#pragma multi_compile __ FILTER_INACTIVE_CELLS

#pragma kernel Simulate_DefaultLight
#pragma kernel Simulate_PointLight
#pragma kernel Simulate_SpotLight
#pragma kernel Simulate_LaserLight
#pragma kernel Simulate_AmbientLight
#pragma kernel Simulate_FieldLight
#pragma kernel Simulate_DirectionalLight
#pragma kernel Simulate_DefaultLight_Forward
#pragma kernel Simulate_PointLight_Forward
#pragma kernel Simulate_SpotLight_Forward
#pragma kernel Simulate_LaserLight_Forward
#pragma kernel Simulate_AmbientLight_Forward
#pragma kernel Simulate_FieldLight_Forward
#pragma kernel Simulate_DirectionalLight_Forward
#pragma kernel Simulate_View_Backward
#pragma kernel ConvertToHDR
#pragma kernel ToneMap
#pragma kernel GetCellTransmissibility
#pragma kernel MeasureConvergence
#pragma kernel GenerateGBufferMips
#pragma kernel ComputeGBufferVariance
#pragma kernel GenerateGBufferQuadTree
#pragma kernel GenerateTrainingSubstrate_MakeShapes
#pragma kernel GenerateTrainingSubstrate_EdgeBlur_JFA
#pragma kernel GenerateTrainingSubstrate_EdgeBlur
#pragma kernel GenerateTrainingSubstrate_AddNoise
#pragma kernel GenerateTrainingSubstrate_Gradient
#pragma kernel GenerateTrainingSubstrate_Hardness

struct Ray {
    float2 Origin;
    float2 Direction;
    uint3 Energy;
    float FineScale;
};

RWStructuredBuffer<uint4> g_rand;
RWTexture2D<uint> g_photons_final;
Texture2D<float4> g_albedo;
Texture2D<float4> g_transmissibility;
SamplerState samplerg_transmissibility;
Texture2D<float4> g_normalSlope;
Texture2D<float4> g_quadTreeLeaves;

DECLARE_LUT(float2, g_mieScatteringLUT)
DECLARE_LUT(float3, g_teardropScatteringLUT)
DECLARE_LUT(float2, g_quantumTunnelingLUT)

RWTexture2D<float4> g_result;
RWTexture2D<float4> g_previousResult;
RWStructuredBuffer<uint> g_convergenceResult;

struct ConvergenceCellInput {
    uint IsActive;
    uint HasConverged;
    uint FrameCount;
    float Reserved[1];
};

struct ConvergenceCellOutput {
    uint MaxValue;
    uint PixelChange;
    uint PhotonCount;
    float Transmissibility;
};

uint4 g_convergenceCells;
RWStructuredBuffer<ConvergenceCellInput> g_convergenceCellStateIn;
RWStructuredBuffer<ConvergenceCellOutput> g_convergenceCellStateOut;

uint g_time_ms;
uint g_photons_per_thread;
uint g_samples_per_pixel;
uint2 g_target_size;
float g_energy_norm;
uint g_bounces;
float g_mip_test;
uint g_lowest_lod;
uint g_4x4_lod;
float g_path_balance;
float2 g_importance_sampling_target;

float g_outscatterCoefficient;
uint3 g_lightEnergy;
float g_lightEmissionOutscatter;

float2x3 g_worldToViewport;
float2x3 g_viewportToTarget;
float2x3 g_worldToTarget;
float2x3 g_lightToWorld;
float4x4 g_lightToTarget;

SamplerState sampler_point_clamp;
SamplerState sampler_linear_clamp;


////////////////
// RANDOM NUMBER GENERATION
////////////////

float Rand_Next(inout RandomContext __rc) {
    __rc = NextRandom(__rc);
    return __rc.value;
}

#define INIT_RAND(seed) RandomContext __rc = CreateRandomContext(seed);
#define RAND() Rand_Next(__rc)
#define RAND_RANGE(lo,hi) (lo + Rand_Next(__rc) * (hi - lo))
#define RAND2() float2(RAND(), RAND())
#define RAND3() float3(RAND(), RAND(), RAND())
#define RAND4() float4(RAND(), RAND(), RAND(), RAND())
#define RAND_DIRECTION() Rand_Direction_(__rc)
#define RAND_CIRCLE() Rand_Circle_(__rc)
#define RAND_SCATTER_MIE(incoming) Rand_Scatter_Mie_(__rc, incoming)
#define RAND_LUT(lutName) SampleLUT(lutName,RAND())
#define SAVE_RAND(seed) seed = __rc.state;

float2 Rand_Direction_(inout RandomContext __rc) {
    float theta = RAND() * 2 * PI;
    float2 dir;
    sincos(theta, dir.x, dir.y);
    return dir;
}

float2 Rand_Circle_(inout RandomContext __rc) {
    return RAND_DIRECTION() * sqrt(RAND());
}

float2 Rand_Scatter_Mie_(inout RandomContext __rc, float2 incomingDirection) {
    float2 perp = incomingDirection.yx;
    perp.x *= -1;

    float2 scatter = RAND_LUT(g_mieScatteringLUT);
    return scatter.x * incomingDirection + scatter.y * perp;
}

float3 Rand_Scatter_Importance(inout RandomContext __rc, float2 origin) {
    float2 important_direction = g_importance_sampling_target - origin;
    float lsq = dot(important_direction, important_direction);

    if(false && dot(important_direction, important_direction) < 1/16.0) {
        return float3(RAND_DIRECTION(), 1);
    } else {
        important_direction /= -sqrt(lsq);
        float2 perp = float2(-important_direction.y, important_direction.x);
        float3 sample = RAND_LUT(g_teardropScatteringLUT);
        return float3(important_direction * sample.x + perp * sample.y, sample.z);
    }
}

////////////////
// I/O
////////////////

int GetGridCellIndex(uint2 pixel) {
    if(any(pixel >= g_target_size)) {
        return -1;
    } else {
        uint2 cellIndex2D = pixel * g_convergenceCells / g_target_size;
        return (int)(cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x);
    }
}

RWTexture2D<uint> g_photons_forward;
uint3 ReadForwardPhoton_Indexed(uint2 pixel) {
    uint3 output;

    pixel.x *= 3;
    output.r = g_photons_forward[pixel];
    pixel.x++;
    output.g = g_photons_forward[pixel];
    pixel.x++;
    output.b = g_photons_forward[pixel];
    
    return output;
}

uint3 ReadForwardPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location * (g_target_size-1) - 0.5f);
}

void WritePhoton_Indexed(int2 pixel, uint3 energy, bool suppressPhoton=false) {
    const uint EnergyMax = (1 << 31);

    uint cellIndex = GetGridCellIndex(pixel);

#if FILTER_INACTIVE_CELLS
    if(cellIndex == -1 || !g_convergenceCellStateIn[cellIndex].IsActive) {
        return;
    }
#endif

    if(!suppressPhoton) {
        InterlockedAdd(g_convergenceCellStateOut[cellIndex].PhotonCount, 1);
    }

    pixel.x *= 3;
    if(g_photons_final[pixel] < EnergyMax)
        InterlockedAdd(g_photons_final[pixel], energy.r);
    pixel.x++;
    if(g_photons_final[pixel] < EnergyMax)
        InterlockedAdd(g_photons_final[pixel], energy.g);
    pixel.x++;
    if(g_photons_final[pixel] < EnergyMax)
        InterlockedAdd(g_photons_final[pixel], energy.b);
}

void WritePhoton(float2 location, uint3 energy, bool suppressPhoton=false) {
    if(any(location < 0)) return;
    WritePhoton_Indexed(location * (g_target_size-1) - 0.5f, energy, suppressPhoton);
}

uint3 ReadPhoton_Indexed(uint2 pixel) {
    uint3 output;
    pixel.x *= 3;
    output.r = g_photons_final[pixel];
    pixel.x++;
    output.g = g_photons_final[pixel];
    pixel.x++;
    output.b = g_photons_final[pixel];
    return output;
}

uint3 ReadPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location * (g_target_size-1) - 0.5f);
}

////////////////
// SIMULATION
////////////////

Ray EmitPointLight(inout RandomContext __rc) {
    Ray emitted;

    float2 pos = RAND_CIRCLE();

    emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;

    float3 important_direction = Rand_Scatter_Importance(__rc, emitted.Origin);
    emitted.Direction = important_direction.xy;
    emitted.Energy = g_lightEnergy;
    emitted.FineScale = important_direction.z;

    return emitted;
} 

Ray EmitSpotLight(inout RandomContext __rc) {
    Ray emitted;

    emitted.Origin = mul(float4(RAND()-0.5, RAND()-0.5, 0, 1), g_lightToTarget).xy;
    emitted.Direction = normalize(mul(float4(2*RAND()-1, -1, 0, 0), g_lightToTarget).xy);
    emitted.Energy = g_lightEnergy;
    emitted.FineScale = 1;

    return emitted;
}

Ray EmitLaserLight(inout RandomContext __rc) {
    Ray emitted;

    emitted.Origin = mul(float4(RAND()-0.5, RAND(), 0, 1), g_lightToTarget).xy;
    emitted.Direction = normalize(mul(float4(0,-1,0,0), g_lightToTarget).xy);
    emitted.Energy = g_lightEnergy;
    emitted.FineScale = 1;

    return emitted;
}

Ray EmitAmbientLight(inout RandomContext __rc) {
    Ray emitted;

    emitted.Origin = float2(RAND(), RAND());
    emitted.Direction = normalize(RAND_DIRECTION() - (emitted.Origin * 2 - 1)/1.44);
    emitted.Energy = g_lightEnergy;
    emitted.FineScale = 1;

    return emitted;
}

Texture2D<float4> g_lightFieldTexture;
Ray EmitFieldLight(inout RandomContext __rc) {
    Ray emitted;

    float2 uv = RAND2();
    float2 pos = uv*2-1;

    float2 _ddx = ddx(g_lightToTarget._m00_m01);
    float2 _ddy = ddy(g_lightToTarget._m10_m11);

    emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
    emitted.Direction = RAND_DIRECTION();
    float4 texValue = g_lightFieldTexture.SampleGrad(sampler_linear_clamp, uv, _ddx, _ddy);
    texValue.rgb *= (texValue.a - 0.08);
    emitted.Energy = g_lightEnergy * texValue.rgb;
    emitted.FineScale = 1;

    return emitted;
}

float2 g_directionalLightDirection;
Ray EmitDirectionalLight(inout RandomContext __rc) {
    Ray emitted;

    float2 perp = g_directionalLightDirection.yx;
    perp.y *= -1;
    emitted.Direction = g_directionalLightDirection;

    emitted.Origin = 0.5 - g_directionalLightDirection + perp * (RAND() * 1.415 - 0.7075);
    emitted.Energy = g_lightEnergy;
    emitted.FineScale = 1;

    return emitted;
}

Ray EmitDefaultLight(inout RandomContext __rc) {
    Ray emitted;

    emitted.Origin = float2(RAND(), 0);
    emitted.Direction = float2(0,1);
    emitted.Energy = float3(0,1000,0);
    emitted.FineScale = 1;

    return emitted;
}

Ray EmitPath(uint2 pixel, inout RandomContext __rc) {
    Ray emitted;

    emitted.Origin = ((float2)pixel + RAND2()) / (g_target_size - 1);
    float3 important_direction = Rand_Scatter_Importance(__rc, emitted.Origin);
    emitted.Direction = important_direction.xy; // RAND_DIRECTION();
    emitted.FineScale = important_direction.z;

    return emitted;
}

float HitTest(Ray photon, out float uHit, float substrateTransmitPotential) {
    float2 pixelSize = 1.0 / g_target_size;

    if(photon.Direction.x == 0) photon.Direction.x = 1e-8;
    if(photon.Direction.y == 0) photon.Direction.y = 1e-8;

    float4 uBoundaryBox = (float4(0,1,0,1) - photon.Origin.xxyy) / photon.Direction.xxyy;
    float uEscape = min(max(uBoundaryBox[0], uBoundaryBox[1]), max(uBoundaryBox[2], uBoundaryBox[3]));

    // Raycast to find collision or escape point
    float uCollision = 10;
    float uEnd = min(uEscape, uCollision);
    
    // float uTarget = RAND() * uEnd;
    float netTransmissibility = 1;

    uHit = 0;
    for(int steps = 0;steps < 2000;steps++) {
        float2 pSample = photon.Origin + photon.Direction * uHit;
        uint lod = g_quadTreeLeaves.SampleLevel(sampler_point_clamp, pSample, 0).x;
    
        float4 T = g_transmissibility.SampleLevel(samplerg_transmissibility, pSample, lod);
        float minimumTransmissibility = T.y;
        while(minimumTransmissibility * netTransmissibility < substrateTransmitPotential && lod > 0) {
            lod--;
            T = g_transmissibility.SampleLevel(samplerg_transmissibility, pSample, lod);
            minimumTransmissibility = T.y;
        }
    
        float transmissibility = T.x;
        netTransmissibility *= transmissibility;

        if(substrateTransmitPotential > netTransmissibility) { // Scatter occurs within this sample
            // The following line finds the hit point at sub-pixel accuracy
            //uHit += w * log2(substrateTransmitPotential / netTransmissibility) / log2(transmissibility);
            return true;
        } else { // Keep propagating
            uHit += pixelSize.x * (1 << lod);

            if(uHit > uEnd) {
                return false;
            }
        }
    }

    // Fail condition... traversal took too many steps
    WritePhoton(photon.Origin, uint3(1000000000, 1000000000, 0));
    return false;
}

void GetSubstrateTransmitPDF(float rand, out float substrateTransmitPotential, out float quantumScale) {
    // substrateTransmitPotential = rand * rand;
    // quantumScale = 2 * rand;

    substrateTransmitPotential = rand * rand * rand;
    quantumScale = 3 * rand * rand;
}

void SimulateLight(Ray photon, inout RandomContext __rc) {
    if(g_lightEmissionOutscatter != 0) {
        uint3 emissionOutscatter = photon.Energy * g_lightEmissionOutscatter;
        WritePhoton(photon.Origin, emissionOutscatter, true);
    }

    for(uint bounce = 0;bounce < g_bounces;bounce++) {
        float uScatter;
        float substrateTransmitPotential;
        float quantumScale;
        GetSubstrateTransmitPDF(RAND(), substrateTransmitPotential, quantumScale);

        bool hit = HitTest(photon, uScatter, substrateTransmitPotential);

        if(!hit) break;

        photon.Origin += photon.Direction * uScatter;

        float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, photon.Origin, 0).rgb;

        photon.Energy *= albedo * quantumScale;

        uint3 outScatter = photon.Energy * photon.FineScale * g_outscatterCoefficient;

        WritePhoton(photon.Origin, outScatter, false);//bounce == 0);
        float3 important_direction = Rand_Scatter_Importance(__rc, photon.Origin);
        photon.Direction = important_direction.xy; //RAND_DIRECTION();
        photon.FineScale *= important_direction.z;
        photon.Energy -= outScatter;
    }
}

void SimulateForward(Ray photon, inout RandomContext __rc) {
    float uScatter;
    float substrateTransmitPotential;
    float quantumScale;
    GetSubstrateTransmitPDF(RAND(), substrateTransmitPotential, quantumScale);
    
    bool hit = HitTest(photon, uScatter, substrateTransmitPotential);

    if(hit) {
        photon.Energy *= g_albedo.SampleLevel(sampler_point_clamp, photon.Origin, 0).rgb;
        WritePhoton(photon.Origin + photon.Direction * uScatter, photon.Energy * photon.FineScale * quantumScale * g_outscatterCoefficient);
    }
}

uint3 SimulateBackward(Ray path, inout RandomContext __rc) {
    float uScatter;
    float substrateTransmitPotential;
    float quantumScale;
    GetSubstrateTransmitPDF(RAND(), substrateTransmitPotential, quantumScale);
    
    bool hit = HitTest(path, uScatter, substrateTransmitPotential);
    
    if(hit) {
        return ReadForwardPhoton(path.Origin + path.Direction * uScatter) * path.FineScale * quantumScale;
    } else {
        return 0;
    }
}

#define SIMULATION_IMPLEMENTATION_LIGHT(lightType)              \
[numthreads(64,1,1)]                                            \
void Simulate_##lightType (uint3 id : SV_DispatchThreadID) {    \
    INIT_RAND(g_rand[id.x])                                     \
    for(uint i = 0;i < g_photons_per_thread;i++) {              \
        SimulateLight(Emit##lightType(__rc), __rc); }           \
    SAVE_RAND(g_rand[id.x])                                     \
}

#define SIMULATION_IMPLEMENTATION_FORWARD(lightType)                        \
[numthreads(64,1,1)]                                                        \
void Simulate_##lightType##_Forward (uint3 id : SV_DispatchThreadID) {      \
    INIT_RAND(g_rand[id.x])                                                 \
    for(uint i = 0;i < g_photons_per_thread;i++) {                          \
        SimulateForward(Emit##lightType(__rc), __rc); }                     \
    SAVE_RAND(g_rand[id.x])                                                 \
}

#define SIMULATION_IMPLEMENTATION(lightType)        \
    SIMULATION_IMPLEMENTATION_LIGHT(lightType)      \
    SIMULATION_IMPLEMENTATION_FORWARD(lightType)

SIMULATION_IMPLEMENTATION(DefaultLight)
SIMULATION_IMPLEMENTATION(PointLight)
SIMULATION_IMPLEMENTATION(SpotLight)
SIMULATION_IMPLEMENTATION(LaserLight)
SIMULATION_IMPLEMENTATION(AmbientLight)
SIMULATION_IMPLEMENTATION(FieldLight)
SIMULATION_IMPLEMENTATION(DirectionalLight)

[numthreads(8,8,1)]
void Simulate_View_Backward (uint3 id : SV_DispatchThreadID) {

#if FILTER_INACTIVE_CELLS
    if(!g_convergenceCellStateIn[GetGridCellIndex((int2)id.xy)].IsActive) {
        return;
    }
#endif

    uint randIndex = id.x + g_target_size.x * id.y; // need wigth * height rand contexts
    INIT_RAND(g_rand[randIndex])
    uint3 sum = 0;

    if(g_path_balance != 1) {
        for(uint i = 0;i < g_samples_per_pixel;i++) {
            sum += SimulateBackward(EmitPath(id.xy, __rc), __rc); 
        }
        sum *= g_albedo.Load(uint3(id.xy,0)).rgb / g_samples_per_pixel;

        sum = lerp(sum, ReadForwardPhoton_Indexed(id.xy), g_path_balance);
    } else {
        sum = ReadForwardPhoton_Indexed(id.xy);
    }

    WritePhoton_Indexed((int2)id.xy, sum, true);
    SAVE_RAND(g_rand[randIndex])
}


/////////////////////////
// OUTPUT PROCESSING
/////////////////////////

RWTexture2D<float4> g_hdrResult;
[numthreads(8,8,1)]
void ConvertToHDR (uint3 id : SV_DispatchThreadID) {
    g_hdrResult[id.xy] = float4(ReadPhoton_Indexed(id.xy) / g_energy_norm, 1);
}

float3 ToneMap_ApproximationA(float3 x) {
    x = max(0, x - 0.004);
    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);
}

[numthreads(8,8,1)]
void ToneMap (uint3 id : SV_DispatchThreadID) {
    ConvergenceCellInput cellData = g_convergenceCellStateIn[GetGridCellIndex((int2)id.xy)];
    float totalEnergyNorm = g_energy_norm * cellData.FrameCount;

    //g_result[id.xy] = float4(ToneMap_ApproximationA(output.rgb), 1);
    g_result[id.xy] = float4(smoothstep(-4, 2, log10(ReadPhoton_Indexed(id.xy) / totalEnergyNorm)), 1); // bit silly but... works?

    if(!cellData.IsActive) {
        g_result[id.xy] *= float4(1,0.6,0.6,1);
    }
}

float g_getCellTransmissibility_lod;
[numthreads(8,8,1)]
void GetCellTransmissibility(uint3 id : SV_DispatchThreadID) {
    uint cellIndex = id.y * g_convergenceCells.x + id.x;
    float2 uv = (id.xy + 0.5) / g_convergenceCells;

    g_convergenceCellStateOut[cellIndex].Transmissibility =
        g_transmissibility.SampleLevel(samplerg_transmissibility, uv, g_getCellTransmissibility_lod).x;
}

[numthreads(8,8,1)]
void MeasureConvergence (uint3 id : SV_DispatchThreadID) {
    //const uint EnergyMax = (1 << 31);

    float4 a = pow(g_result[id.xy], 1/2.2);
    float4 b = pow(g_previousResult[id.xy], 1/2.2);

    uint3 photon = ReadPhoton_Indexed(id.xy);
    uint pixelMax = max(photon.r, max(photon.g, photon.b));

    float4 delta = abs(a - b) * 256;
    uint diff = uint(dot(delta,1) * 100.0);

    uint2 cellIndex2D = id.xy * g_convergenceCells / g_target_size;
    uint cellIndex = cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x;

    InterlockedAdd(g_convergenceCellStateOut[cellIndex].PixelChange, diff);
    InterlockedMax(g_convergenceCellStateOut[cellIndex].MaxValue, pixelMax);
}


/////////////////////////
// G BUFFER PROCESSING
/////////////////////////

RWTexture2D<float4> g_sourceMipLevelAlbedo;
RWTexture2D<float4> g_sourceMipLevelNormalSlope;
RWTexture2D<float4> g_sourceMipLevelTransmissibility;
RWTexture2D<float4> g_destMipLevelAlbedo;
RWTexture2D<float4> g_destMipLevelNormalSlope;
RWTexture2D<float4> g_destMipLevelTransmissibility;
RWTexture2D<float4> g_destQuadTreeLeaves;

float g_TransmissibilityVariationEpsilon;

float4 DownsampleAlbedo(uint2 id) {
    float4 a = g_sourceMipLevelAlbedo[id + uint2(0,0)];
    float4 b = g_sourceMipLevelAlbedo[id + uint2(1,0)];
    float4 c = g_sourceMipLevelAlbedo[id + uint2(0,1)];
    float4 d = g_sourceMipLevelAlbedo[id + uint2(1,1)];

    return (a+b+c+d)/4;
}

float4 DownsampleTransmissibility(uint2 id) {
    float4 a = g_sourceMipLevelTransmissibility[id + uint2(0,0)];
    float4 b = g_sourceMipLevelTransmissibility[id + uint2(1,0)];
    float4 c = g_sourceMipLevelTransmissibility[id + uint2(0,1)];
    float4 d = g_sourceMipLevelTransmissibility[id + uint2(1,1)];

    float at = 1 / (a.x + 1);
    float bt = 1 / (b.x + 1);
    float ct = 1 / (c.x + 1);
    float dt = 1 / (d.x + 1);

    float average = (a.x*b.x + c.x*d.x + a.x*c.x + b.x*d.x) / 4;
    float minimum = min(min(a.y*b.y, c.y*d.y), min(a.y*c.y, b.y*d.y));

    float sr_avg = sqrt(average);
    float4 variances = float4(a.x,b.x,c.x,d.x) - sr_avg;
    variances *= variances;
    float variance = dot(variances, 0.25);
    float leaf = (variance < g_TransmissibilityVariationEpsilon) ? 1 : 0;

    return float4(average, minimum, leaf, 1);
}

float4 DownsampleNormalSlope(uint2 id) {
    float4 a = g_sourceMipLevelNormalSlope[id + uint2(0,0)];
    float4 b = g_sourceMipLevelNormalSlope[id + uint2(1,0)];
    float4 c = g_sourceMipLevelNormalSlope[id + uint2(0,1)];
    float4 d = g_sourceMipLevelNormalSlope[id + uint2(1,1)];

    return float4(normalize(a.xy + b.xy + c.xy + d.xy), (a.zw + b.zw + c.zw + d.zw) / 4);
}

[numthreads(8,8,1)]
void GenerateGBufferMips (uint3 id : SV_DispatchThreadID) {
    g_destMipLevelAlbedo[id.xy] = DownsampleAlbedo(id.xy * 2);
    g_destMipLevelTransmissibility[id.xy] = DownsampleTransmissibility(id.xy * 2);
    g_destMipLevelNormalSlope[id.xy] = DownsampleNormalSlope(id.xy * 2);
}

void ComputeTransmissibilityVariance(uint2 id) {

    float3 r1 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1,-1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0,-1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1,-1)].x
    );
    float3 r2 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1, 0)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0, 0)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1, 0)].x
    );
    float3 r3 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1, 1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0, 1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1, 1)].x
    );

    
    float mean = dot(r1, 1/9.0) + dot(r2, 1/9.0) + dot(r3, 1/9.0);
    
    float3 d1 = r1 - mean;
    float3 d2 = r2 - mean;
    float3 d3 = r3 - mean;

    float variance = sqrt(dot(d1,d1) + dot(d2,d2) + dot(d3,d3)) / 3.0;
    float leaf = (variance < g_TransmissibilityVariationEpsilon) ? 1 : 0;

    float4 newValue = g_sourceMipLevelTransmissibility[id];
    newValue.z = variance;
    newValue.w = leaf;
    g_sourceMipLevelTransmissibility[id] = newValue;
}

[numthreads(8,8,1)]
void ComputeGBufferVariance (uint3 id : SV_DispatchThreadID) {
    ComputeTransmissibilityVariance(id.xy);
}

[numthreads(8,8,1)]
void GenerateGBufferQuadTree (uint3 id : SV_DispatchThreadID) {
    float2 uv = (id.xy + 0.5) / g_target_size;
    for(int i = g_lowest_lod;i >= 0;i--) {
        float4 leaf = g_transmissibility.SampleLevel(samplerg_transmissibility, uv, i);

        if(leaf.w == 1) {
            g_destQuadTreeLeaves[id.xy] = float4(i,0,0,1);
           break;
        }
  }
}

////////////////////////////////
// TRAINING SCENE GENERATORS
/////////////////////////////////

RWTexture2D<float4> g_trainingSubstrate_textureDest;
RWTexture2D<float4> g_trainingSubstrate_textureRef;
float2 g_trainingSubstrate_size;
int4 g_trainingSubstrate_ShapeCounts; // (Rect, Ellipse, Inverse Rect, Inverse Ellipse)
float4x4 g_trainingSubstrate_ShapeTransforms[16];
float g_trainingSubstrate_edgeBlur;
float2 g_trainingSubstrate_noiseSeed;
float2 g_trainingSubstrate_noiseFrequencyMinMax;
float2 g_trainingSubstrate_noiseClipValues;
float3 g_trainingSubstrate_gradientDirection;
float2 g_trainingSubstrate_gradientDensity;
float3 g_trainingSubstrate_gradientColorA;
float3 g_trainingSubstrate_gradientColorB;
float g_trainingSubstrate_hardness;

[numthreads(8,8,1)]
void GenerateTrainingSubstrate_MakeShapes(uint3 id : SV_DispatchThreadID) {
    int totalRects = g_trainingSubstrate_ShapeCounts.x;
    int totalEllipses = g_trainingSubstrate_ShapeCounts.y;
    int totalInverseRects = g_trainingSubstrate_ShapeCounts.z;
    int totalInverseEllipses = g_trainingSubstrate_ShapeCounts.w;

    float2 xy = ((float2)id.xy + 0.5) / g_trainingSubstrate_size * 2 - 1;

    // Draw shapes!
    bool inside = false;
    int currentTransformIndex = 0;
    int i;
    for(i = 0;i < totalRects;i++) {
        float2 txy = mul(float4(xy,0,1), g_trainingSubstrate_ShapeTransforms[currentTransformIndex]).xy;
        inside = inside || all(abs(txy.xy) <= 1);
        currentTransformIndex++;
    }
    for(i = 0;i < totalEllipses;i++) {
        float2 txy = mul(float4(xy,0,1), g_trainingSubstrate_ShapeTransforms[currentTransformIndex]).xy;
        inside = inside || dot(txy.xy, txy.xy) <= 1;
        currentTransformIndex++;
    }
    for(i = 0;i < totalInverseRects;i++) {
        float2 txy = mul(float4(xy,0,1), g_trainingSubstrate_ShapeTransforms[currentTransformIndex]).xy;
        inside = inside && !all(abs(txy.xy) <= 1);
        currentTransformIndex++;
    }
    for(i = 0;i < totalInverseEllipses;i++) {
        float2 txy = mul(float4(xy,0,1), g_trainingSubstrate_ShapeTransforms[currentTransformIndex]).xy;
        inside = inside && !(dot(txy.xy, txy.xy) <= 1);
        currentTransformIndex++;
    }

    if(inside) {
        g_trainingSubstrate_textureDest[id.xy] = float4(1,   -1,   -1, 1);
    } else {
        g_trainingSubstrate_textureDest[id.xy] = float4(0, id.x, id.y, 0);
    }

    // - 2. Edge blur.
    // - 3. noise or no?
    // - 4. If yes, choose frequencies (min/max, pow2), floor, ceiling, and modulate
    // - 6. Intensity and color (linear gradient)
    // - 5. Grade power (0.1..10) or x^(10^(RAND()*2-1))
    // - 7. Apply and Repeat (1-4 times total)
}

int g_trainingSubstrate_edgeBlurStage;
[numthreads(8,8,1)]
void GenerateTrainingSubstrate_EdgeBlur_JFA(uint3 id : SV_DispatchThreadID) {
    float2 closest;
    float closest_distance = 1.e6;

    float4 pixel = g_trainingSubstrate_textureRef[id.xy];

    if(pixel.x == 0) {
        g_trainingSubstrate_textureDest[id.xy] = pixel;
        return;
    }

    for(int i = -1;i <= 1;i++) {
        for(int j = -1;j <= 1;j++) {
            float4 c = g_trainingSubstrate_textureRef[id.xy +
                uint2(i * g_trainingSubstrate_edgeBlurStage,
                      j * g_trainingSubstrate_edgeBlurStage)];

            if(c.y != -1) {
                float2 delta = c.yz - id.xy;
                float c_dist = dot(delta, delta);
                if(c_dist < closest_distance) {
                    closest = c.yz;
                    closest_distance = c_dist;
                }
            }
        }
    }

    pixel.yz = closest;
    g_trainingSubstrate_textureDest[id.xy] = pixel;
}

[numthreads(8,8,1)]
void GenerateTrainingSubstrate_EdgeBlur(uint3 id : SV_DispatchThreadID) {
    float4 pixel = g_trainingSubstrate_textureRef[id.xy];
    float dist = length(pixel.yz - id.xy);
    dist /= (g_trainingSubstrate_edgeBlur + 1);
    g_trainingSubstrate_textureDest[id.xy] = float4(pixel.rgb, pixel.a * saturate(dist));
}

[numthreads(8,8,1)]
void GenerateTrainingSubstrate_AddNoise(uint3 id : SV_DispatchThreadID) {
    INIT_RAND(0)
    
    float max_amplitude = 0;
    float amplitude = 1;
    float freq = g_trainingSubstrate_noiseFrequencyMinMax.x;
    float2 uv = (id.xy + 0.5) / g_trainingSubstrate_size + g_trainingSubstrate_noiseSeed;

    float noise_cloud = 0;
    while(freq <= g_trainingSubstrate_noiseFrequencyMinMax.y) {
        noise_cloud += amplitude * snoise01(uv.xy * freq);
        max_amplitude += amplitude;
        amplitude /= 2;
        freq *= 2;
        uv += 10*RAND();
    }

    noise_cloud /= max_amplitude;  // ensure bounds [0,1]
    noise_cloud -= g_trainingSubstrate_noiseClipValues.x; // floor moved to 0
    noise_cloud /= (g_trainingSubstrate_noiseClipValues.y - g_trainingSubstrate_noiseClipValues.x); // ceiling scaled to 1
    noise_cloud = saturate(noise_cloud); // clamp to [0,1] again

    float4 pixel = g_trainingSubstrate_textureRef[id.xy];
    g_trainingSubstrate_textureDest[id.xy] = float4(pixel.rgb, pixel.a * noise_cloud);
}

[numthreads(8,8,1)]
void GenerateTrainingSubstrate_Gradient(uint3 id : SV_DispatchThreadID) {
    float2 xy = (id.xy + 0.5) / g_trainingSubstrate_size * 2 - 1;
    float grad = saturate(dot(g_trainingSubstrate_gradientDirection, float3(xy, 1)));
    float density = lerp(g_trainingSubstrate_gradientDensity.x, g_trainingSubstrate_gradientDensity.y, grad);
    float3 color = lerp(g_trainingSubstrate_gradientColorA, g_trainingSubstrate_gradientColorB, grad);

    float4 pixel = g_trainingSubstrate_textureRef[id.xy];

    float net_density;
    if(density > 1) {
        net_density = lerp(pixel.a, 1, density - 1);
    } else {
        net_density = pixel.a * density;
    }

    g_trainingSubstrate_textureDest[id.xy] = float4(color, net_density);
}

[numthreads(8,8,1)]
void GenerateTrainingSubstrate_Hardness(uint3 id : SV_DispatchThreadID) {
    float4 pixel = g_trainingSubstrate_textureRef[id.xy];
    float4 l = g_trainingSubstrate_textureRef[id.xy - uint2(1,0)];
    float4 r = g_trainingSubstrate_textureRef[id.xy + uint2(1,0)];
    float4 u = g_trainingSubstrate_textureRef[id.xy + uint2(0,1)];
    float4 d = g_trainingSubstrate_textureRef[id.xy - uint2(0,1)];

    float4 avg = pixel / 2 + (l + r + u + d) / 8;
    g_trainingSubstrate_textureDest[id.xy] = float4(pixel.xyz, pow(pixel.a, g_trainingSubstrate_hardness));
}