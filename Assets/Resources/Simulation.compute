#include "../Shaders/RayTracing2DCommon.cginc"
#include "../Shaders/Random.cginc"

#pragma multi_compile __ FILTER_INACTIVE_CELLS

#pragma kernel Simulate_DefaultLight
#pragma kernel Simulate_PointLight
#pragma kernel Simulate_SpotLight
#pragma kernel Simulate_LaserLight
#pragma kernel Simulate_AmbientLight
#pragma kernel Simulate_FieldLight
#pragma kernel Simulate_DirectionalLight
#pragma kernel Simulate_DefaultLight_Forward
#pragma kernel Simulate_PointLight_Forward
#pragma kernel Simulate_SpotLight_Forward
#pragma kernel Simulate_LaserLight_Forward
#pragma kernel Simulate_AmbientLight_Forward
#pragma kernel Simulate_FieldLight_Forward
#pragma kernel Simulate_DirectionalLight_Forward
#pragma kernel Simulate_View_Backward
#pragma kernel AccumulatePhotons
#pragma kernel ConvertToHDR
#pragma kernel ToneMap
#pragma kernel GetCellTransmissibility
#pragma kernel MeasureConvergence
#pragma kernel GenerateGBufferMips
#pragma kernel ComputeGBufferVariance
#pragma kernel GenerateGBufferQuadTree

struct Ray {
    float2 Origin;
    float2 Direction;
    uint3 Energy;
    float FineScale;
};

RWStructuredBuffer<uint4> g_rand;
RWTexture2D<uint> g_photons_forward;
RWTexture2D<uint> g_output_raw;
Texture2D<float4> g_albedo;
Texture2D<float4> g_transmissibility;
SamplerState samplerg_transmissibility;
Texture2D<float4> g_normalSlope;
Texture2D<float4> g_quadTreeLeaves;

DECLARE_LUT(float2, g_mieScatteringLUT)
DECLARE_LUT(float3, g_teardropScatteringLUT)
DECLARE_LUT_3D(float2, g_quantumTunnelingLUT)

RWTexture2D<float4> g_output_tonemapped;
RWTexture2D<float4> g_previousResult;
RWStructuredBuffer<uint> g_convergenceResult;

struct ConvergenceCellInput {
    uint IsActive;
    uint HasConverged;
    uint FrameCount;
    float TargetTransmission;
    float TransmissionSpread;
    float Reserved[3];
};

struct ConvergenceCellOutput {
    uint MaxValue;
    uint PixelChange;
    uint PhotonCount;
    float Transmissibility;
};

uint4 g_convergenceCells;
RWStructuredBuffer<ConvergenceCellInput> g_convergenceCellStateIn;
RWStructuredBuffer<ConvergenceCellOutput> g_convergenceCellStateOut;

uint g_time_ms;
uint g_photons_per_thread;
uint g_samples_per_pixel;
uint2 g_target_size;
float g_energy_norm;
uint g_bounces;
float g_mip_test;
uint g_lowest_lod;
uint g_4x4_lod;
float g_path_balance;
float2 g_importance_sampling_target;

float g_outscatterCoefficient;
uint3 g_lightEnergy;
float g_lightEmissionOutscatter;

float2x3 g_worldToViewport;
float2x3 g_viewportToTarget;
float2x3 g_worldToTarget;
float2x3 g_lightToWorld;
float4x4 g_lightToTarget;

SamplerState sampler_point_clamp;
SamplerState sampler_linear_clamp;

////////////////
// I/O
////////////////

int GetGridCellIndex(uint2 pixel) {
    if(any(pixel >= g_target_size)) {
        return -1;
    } else {
        uint2 cellIndex2D = pixel * g_convergenceCells / g_target_size;
        return (int)(cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x);
    }
}

uint3 ReadForwardPhoton_Indexed(uint2 pixel) {
    uint3 output;

    pixel.x *= 3;
    output.r = g_photons_forward[pixel];
    pixel.x++;
    output.g = g_photons_forward[pixel];
    pixel.x++;
    output.b = g_photons_forward[pixel];
    
    return output;
}

uint3 ReadForwardPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location * (g_target_size-1) - 0.5f);
}

void ClearPhoton_Indexed(int2 pixel) {
    pixel.x *= 3;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
}

void WritePhoton_Indexed(int2 pixel, uint3 energy, bool suppressPhoton=false) {
    const uint EnergyMax = (1 << 31);

    uint cellIndex = GetGridCellIndex(pixel);

#if FILTER_INACTIVE_CELLS
    if(cellIndex == -1 || !g_convergenceCellStateIn[cellIndex].IsActive) {
        return;
    }
#endif

    if(!suppressPhoton) {
        InterlockedAdd(g_convergenceCellStateOut[cellIndex].PhotonCount, 1);
    }

    pixel.x *= 3;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.r);
    pixel.x++;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.g);
    pixel.x++;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.b);
}

void WritePhoton(float2 location, uint3 energy, bool suppressPhoton=false) {
    if(any(location < 0)) return;
    WritePhoton_Indexed(location * (g_target_size-1) - 0.5f, energy, suppressPhoton);
}

uint3 ReadPhoton_Indexed(uint2 pixel) {
    uint3 output;
    pixel.x *= 3;
    output.r = g_output_raw[pixel];
    pixel.x++;
    output.g = g_output_raw[pixel];
    pixel.x++;
    output.b = g_output_raw[pixel];
    return output;
}

uint3 ReadPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location * (g_target_size-1) - 0.5f);
}

////////////////
// SIMULATION
////////////////

Texture2D<float4> g_lightFieldTexture;
float2 g_directionalLightDirection;

struct SimulationContext {
    Random rand;

    void Init(uint4 seed) {
        rand.Init(seed);
    }

    float2 ScatterMie(float2 incomingDirection) {
        float2 perp = incomingDirection.yx;
        perp.x *= -1;
    
        float2 scatter = SampleLUT(g_mieScatteringLUT, rand.Next());
        return scatter.x * incomingDirection + scatter.y * perp;
    }
    
    float3 ScatterImportance(float2 origin) {
        float2 important_direction = g_importance_sampling_target - origin;
        float lsq = dot(important_direction, important_direction);
    
        if(false && dot(important_direction, important_direction) < 1/16.0) {
            return float3(rand.NextDirection(), 1);
        } else {
            important_direction /= -sqrt(lsq);
            float2 perp = float2(-important_direction.y, important_direction.x);
            float3 sample = SampleLUT(g_teardropScatteringLUT, rand.Next());
            return float3(important_direction * sample.x + perp * sample.y, sample.z);
        }
    }

    Ray EmitPointLight() {
        Ray emitted;
        
        float2 pos = rand.NextCircle();
        
        emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
        
        float3 important_direction = ScatterImportance(emitted.Origin);
        emitted.Direction = important_direction.xy;
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = important_direction.z;

        return emitted;
    } 

    Ray EmitSpotLight() {
        Ray emitted;

        emitted.Origin = mul(float4(rand.Next()-0.5, rand.Next()-0.5, 0, 1), g_lightToTarget).xy;
        emitted.Direction = normalize(mul(float4(2*rand.Next()-1, -1, 0, 0), g_lightToTarget).xy);
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitLaserLight() {
        Ray emitted;

        emitted.Origin = mul(float4(rand.Next()-0.5, rand.Next(), 0, 1), g_lightToTarget).xy;
        emitted.Direction = normalize(mul(float4(0,-1,0,0), g_lightToTarget).xy);
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitAmbientLight() {
        Ray emitted;

        emitted.Origin = rand.Next2();
        emitted.Direction = normalize(rand.NextDirection() - (emitted.Origin * 2 - 1)/1.44);
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitFieldLight() {
        Ray emitted;

        float2 uv = rand.Next2();
        float2 pos = uv*2-1;

        float2 _ddx = ddx(g_lightToTarget._m00_m01);
        float2 _ddy = ddy(g_lightToTarget._m10_m11);

        emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
        emitted.Direction = rand.NextDirection();
        float4 texValue = g_lightFieldTexture.SampleGrad(sampler_linear_clamp, uv, _ddx, _ddy);
        texValue.rgb *= (texValue.a - 0.08);
        emitted.Energy = g_lightEnergy * texValue.rgb;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitDirectionalLight() {
        Ray emitted;

        float2 perp = g_directionalLightDirection.yx;
        perp.y *= -1;
        emitted.Direction = g_directionalLightDirection;

        emitted.Origin = 0.5 - g_directionalLightDirection + perp * (rand.Next() * 1.415 - 0.7075);
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitDefaultLight() {
        Ray emitted;

        emitted.Origin = float2(rand.Next(), 0);
        emitted.Direction = float2(0,1);
        emitted.Energy = float3(0,1000,0);
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitPath(uint2 pixel) {
        Ray emitted;

        emitted.Origin = ((float2)pixel + rand.Next2()) / (g_target_size - 1);
        float3 important_direction = ScatterImportance(emitted.Origin);
        emitted.Direction = important_direction.xy; // RAND_DIRECTION();
        emitted.FineScale = important_direction.z;

        return emitted;
    }

    float HitTest(Ray photon, out float uHit, float substrateTransmitPotential) {
        float2 pixelSize = 1.0 / g_target_size;

        if(photon.Direction.x == 0) photon.Direction.x = 1e-8;
        if(photon.Direction.y == 0) photon.Direction.y = 1e-8;

        float4 uBoundaryBox = (float4(0,1,0,1) - photon.Origin.xxyy) / photon.Direction.xxyy;
        float uEscape = min(max(uBoundaryBox[0], uBoundaryBox[1]), max(uBoundaryBox[2], uBoundaryBox[3]));

        // Raycast to find collision or escape point
        float uCollision = 10;
        float uEnd = min(uEscape, uCollision);
        
        // float uTarget = RAND() * uEnd;
        float netTransmissibility = 1;

        uHit = 0;
        for(int steps = 0;steps < 2000;steps++) {
            float2 pSample = photon.Origin + photon.Direction * uHit;
            uint lod = g_quadTreeLeaves.SampleLevel(sampler_point_clamp, pSample, 0).x;
        
            float4 T = g_transmissibility.SampleLevel(samplerg_transmissibility, pSample, lod);
            float minimumTransmissibility = T.y;
            while(minimumTransmissibility * netTransmissibility < substrateTransmitPotential && lod > 0) {
                lod--;
                T = g_transmissibility.SampleLevel(samplerg_transmissibility, pSample, lod);
                minimumTransmissibility = T.y;
            }
        
            float transmissibility = T.x;
            netTransmissibility *= transmissibility;

            if(substrateTransmitPotential > netTransmissibility) { // Scatter occurs within this sample
                // The following line finds the hit point at sub-pixel accuracy
                //uHit += w * log2(substrateTransmitPotential / netTransmissibility) / log2(transmissibility);
                return true;
            } else { // Keep propagating
                uHit += pixelSize.x * (1 << lod);

                if(uHit > uEnd) {
                    return false;
                }
            }
        }

        // Fail condition... traversal took too many steps
        WritePhoton(photon.Origin, uint3(1000000000, 1000000000, 0));
        return false;
    }

    void GetSubstrateTransmitPDF(out float substrateTransmitPotential, out float quantumScale) {
        // substrateTransmitPotential = rand * rand;
        // quantumScale = 2 * rand;

        float u = rand.Next();
        substrateTransmitPotential = u * u * u;
        quantumScale = 3 * u * u;
    }

    void SimulateLight(Ray photon) {
        if(g_lightEmissionOutscatter != 0) {
            uint3 emissionOutscatter = photon.Energy * g_lightEmissionOutscatter;
            WritePhoton(photon.Origin, emissionOutscatter, true);
        }

        for(uint bounce = 0;bounce < g_bounces;bounce++) {
            float uScatter;
            float substrateTransmitPotential;
            float quantumScale;
            GetSubstrateTransmitPDF(substrateTransmitPotential, quantumScale);

            bool hit = HitTest(photon, uScatter, substrateTransmitPotential);

            if(!hit) break;

            photon.Origin += photon.Direction * uScatter;

            float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, photon.Origin, 0).rgb;

            photon.Energy *= albedo * quantumScale;

            uint3 outScatter = photon.Energy * photon.FineScale * g_outscatterCoefficient;

            WritePhoton(photon.Origin, outScatter, false);//bounce == 0);
            float3 important_direction = ScatterImportance(photon.Origin);
            photon.Direction = important_direction.xy;
            photon.FineScale *= important_direction.z;
            photon.Energy -= outScatter;
        }
    }

    void SimulateForward(Ray photon) {
        float uScatter;
        float substrateTransmitPotential;
        float quantumScale;
        GetSubstrateTransmitPDF(substrateTransmitPotential, quantumScale);
        
        bool hit = HitTest(photon, uScatter, substrateTransmitPotential);

        if(hit) {
            photon.Energy *= g_albedo.SampleLevel(sampler_point_clamp, photon.Origin, 0).rgb;
            WritePhoton(photon.Origin + photon.Direction * uScatter, photon.Energy * photon.FineScale * quantumScale * g_outscatterCoefficient);
        }
    }

    uint3 SimulateBackward(Ray path) {
        float uScatter;
        float substrateTransmitPotential;
        float quantumScale;
        GetSubstrateTransmitPDF(substrateTransmitPotential, quantumScale);
        
        bool hit = HitTest(path, uScatter, substrateTransmitPotential);
        
        if(hit) {
            return ReadForwardPhoton(path.Origin + path.Direction * uScatter) * path.FineScale * quantumScale;
        } else {
            return 0;
        }
    }
};

SimulationContext CreateSimulationContext(uint4 seed) {
    SimulationContext sim;
    sim.Init(seed);
    return sim;
}

#define SIMULATION_IMPLEMENTATION_LIGHT(lightType)                  \
[numthreads(64,1,1)]                                                \
void Simulate_##lightType (uint3 id : SV_DispatchThreadID) {        \
    SimulationContext sim = CreateSimulationContext(g_rand[id.x]);  \
    for(uint i = 0;i < g_photons_per_thread;i++) {                  \
        sim.SimulateLight(sim.Emit##lightType()); }                 \
    g_rand[id.x] = sim.rand.state;                                  \
}

#define SIMULATION_IMPLEMENTATION_FORWARD(lightType)                    \
[numthreads(64,1,1)]                                                    \
void Simulate_##lightType##_Forward (uint3 id : SV_DispatchThreadID) {  \
    SimulationContext sim = CreateSimulationContext(g_rand[id.x]);      \
    for(uint i = 0;i < g_photons_per_thread;i++) {                      \
        sim.SimulateForward(sim.Emit##lightType()); }                   \
    g_rand[id.x] = sim.rand.state;                                       \
}

#define SIMULATION_IMPLEMENTATION(lightType)        \
    SIMULATION_IMPLEMENTATION_LIGHT(lightType)      \
    SIMULATION_IMPLEMENTATION_FORWARD(lightType)

SIMULATION_IMPLEMENTATION(DefaultLight)
SIMULATION_IMPLEMENTATION(PointLight)
SIMULATION_IMPLEMENTATION(SpotLight)
SIMULATION_IMPLEMENTATION(LaserLight)
SIMULATION_IMPLEMENTATION(AmbientLight)
SIMULATION_IMPLEMENTATION(FieldLight)
SIMULATION_IMPLEMENTATION(DirectionalLight)

[numthreads(8,8,1)]
void Simulate_View_Backward (uint3 id : SV_DispatchThreadID) {

#if FILTER_INACTIVE_CELLS
    if(!g_convergenceCellStateIn[GetGridCellIndex((int2)id.xy)].IsActive) {
        return;
    }
#endif

    uint randIndex = id.x + g_target_size.x * id.y; // need wigth * height rand contexts
    SimulationContext sim = CreateSimulationContext(g_rand[randIndex]);
    uint3 sum = 0;

    if(g_path_balance != 1) {
        for(uint i = 0;i < g_samples_per_pixel;i++) {
            sum += sim.SimulateBackward(sim.EmitPath(id.xy)); 
        }
        sum *= g_albedo.Load(uint3(id.xy,0)).rgb / g_samples_per_pixel;
        sum *= 1-g_transmissibility.Load(uint3(id.xy, 0)).x;
        sum = lerp(sum, ReadForwardPhoton_Indexed(id.xy), g_path_balance);
    } else {
        sum = ReadForwardPhoton_Indexed(id.xy);
    }

    WritePhoton_Indexed((int2)id.xy, sum, true);
    g_rand[randIndex] = sim.rand.state;
}


/////////////////////////
// OUTPUT PROCESSING
/////////////////////////

RWTexture2D<float4> g_output_accumulated;
uint2 g_accumulate_base_index;
[numthreads(8, 8, 1)]
void AccumulatePhotons(uint3 id : SV_DispatchThreadID)
{
    uint2 index = g_accumulate_base_index + id.xy;
    g_output_accumulated[index] += float4(ReadPhoton_Indexed(index) / g_energy_norm, 1);
    ClearPhoton_Indexed(index);
}

RWTexture2D<float4> g_output_hdr;
[numthreads(8,8,1)]
void ConvertToHDR (uint3 id : SV_DispatchThreadID) {
    ConvergenceCellInput cellData = g_convergenceCellStateIn[GetGridCellIndex((int2) id.xy)];
    float frames = cellData.FrameCount;

    g_output_hdr[id.xy] = float4((ReadPhoton_Indexed(id.xy) / g_energy_norm + g_output_accumulated[id.xy].rgb) / frames, 1);
}

float3 ToneMap_ApproximationA(float3 x) {
    x = max(0, x - 0.004);
    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);
}

[numthreads(8,8,1)]
void ToneMap (uint3 id : SV_DispatchThreadID) {
    ConvergenceCellInput cellData = g_convergenceCellStateIn[GetGridCellIndex((int2) id.xy)];
    
    //g_output_tonemapped[id.xy] = float4(ToneMap_ApproximationA(output.rgb), 1);
    g_output_tonemapped[id.xy] = float4(smoothstep(-4, 2, log10(g_output_hdr[id.xy].rgb)), 1); // bit silly but... works?

    if(!cellData.IsActive) {
        g_output_tonemapped[id.xy] *= float4(1,0.6,0.6,1);
    }
}

float g_getCellTransmissibility_lod;
[numthreads(8,8,1)]
void GetCellTransmissibility(uint3 id : SV_DispatchThreadID) {
    uint cellIndex = id.y * g_convergenceCells.x + id.x;
    float2 uv = (id.xy + 0.5) / g_convergenceCells;

    g_convergenceCellStateOut[cellIndex].Transmissibility =
        g_transmissibility.SampleLevel(samplerg_transmissibility, uv, g_getCellTransmissibility_lod).x;
}

[numthreads(8,8,1)]
void MeasureConvergence (uint3 id : SV_DispatchThreadID) {
    //const uint EnergyMax = (1 << 31);

    float4 a = pow(g_output_tonemapped[id.xy], 1/2.2);
    float4 b = pow(g_previousResult[id.xy], 1/2.2);

    uint3 photon = ReadPhoton_Indexed(id.xy);
    uint pixelMax = max(photon.r, max(photon.g, photon.b));

    float4 delta = abs(a - b) * 256;
    uint diff = uint(dot(delta,1) * 100.0);

    uint2 cellIndex2D = id.xy * g_convergenceCells / g_target_size;
    uint cellIndex = cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x;

    InterlockedAdd(g_convergenceCellStateOut[cellIndex].PixelChange, diff);
    InterlockedMax(g_convergenceCellStateOut[cellIndex].MaxValue, pixelMax);
}


/////////////////////////
// G BUFFER PROCESSING
/////////////////////////

RWTexture2D<float4> g_sourceMipLevelAlbedo;
RWTexture2D<float4> g_sourceMipLevelNormalSlope;
RWTexture2D<float4> g_sourceMipLevelTransmissibility;
RWTexture2D<float4> g_destMipLevelAlbedo;
RWTexture2D<float4> g_destMipLevelNormalSlope;
RWTexture2D<float4> g_destMipLevelTransmissibility;
RWTexture2D<float4> g_destQuadTreeLeaves;

float g_TransmissibilityVariationEpsilon;

float4 DownsampleAlbedo(uint2 id) {
    float4 a = g_sourceMipLevelAlbedo[id + uint2(0,0)];
    float4 b = g_sourceMipLevelAlbedo[id + uint2(1,0)];
    float4 c = g_sourceMipLevelAlbedo[id + uint2(0,1)];
    float4 d = g_sourceMipLevelAlbedo[id + uint2(1,1)];

    return (a+b+c+d)/4;
}

float4 DownsampleTransmissibility(uint2 id) {
    float4 a = g_sourceMipLevelTransmissibility[id + uint2(0,0)];
    float4 b = g_sourceMipLevelTransmissibility[id + uint2(1,0)];
    float4 c = g_sourceMipLevelTransmissibility[id + uint2(0,1)];
    float4 d = g_sourceMipLevelTransmissibility[id + uint2(1,1)];

    float at = 1 / (a.x + 1);
    float bt = 1 / (b.x + 1);
    float ct = 1 / (c.x + 1);
    float dt = 1 / (d.x + 1);

    float average = (a.x*b.x + c.x*d.x + a.x*c.x + b.x*d.x) / 4;
    float minimum = min(min(a.y*b.y, c.y*d.y), min(a.y*c.y, b.y*d.y));

    float sr_avg = sqrt(average);
    float4 variances = float4(a.x,b.x,c.x,d.x) - sr_avg;
    variances *= variances;
    float variance = dot(variances, 0.25);
    float leaf = (variance < g_TransmissibilityVariationEpsilon) ? 1 : 0;

    return float4(average, minimum, leaf, 1);
}

float4 DownsampleNormalSlope(uint2 id) {
    float4 a = g_sourceMipLevelNormalSlope[id + uint2(0,0)];
    float4 b = g_sourceMipLevelNormalSlope[id + uint2(1,0)];
    float4 c = g_sourceMipLevelNormalSlope[id + uint2(0,1)];
    float4 d = g_sourceMipLevelNormalSlope[id + uint2(1,1)];

    return float4(normalize(a.xy + b.xy + c.xy + d.xy), (a.zw + b.zw + c.zw + d.zw) / 4);
}

[numthreads(8,8,1)]
void GenerateGBufferMips (uint3 id : SV_DispatchThreadID) {
    g_destMipLevelAlbedo[id.xy] = DownsampleAlbedo(id.xy * 2);
    g_destMipLevelTransmissibility[id.xy] = DownsampleTransmissibility(id.xy * 2);
    g_destMipLevelNormalSlope[id.xy] = DownsampleNormalSlope(id.xy * 2);
}

void ComputeTransmissibilityVariance(uint2 id) {

    float3 r1 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1,-1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0,-1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1,-1)].x
    );
    float3 r2 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1, 0)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0, 0)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1, 0)].x
    );
    float3 r3 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1, 1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0, 1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1, 1)].x
    );

    
    float mean = dot(r1, 1/9.0) + dot(r2, 1/9.0) + dot(r3, 1/9.0);
    
    float3 d1 = r1 - mean;
    float3 d2 = r2 - mean;
    float3 d3 = r3 - mean;

    float variance = sqrt(dot(d1,d1) + dot(d2,d2) + dot(d3,d3)) / 3.0;
    float leaf = (variance < g_TransmissibilityVariationEpsilon) ? 1 : 0;

    float4 newValue = g_sourceMipLevelTransmissibility[id];
    newValue.z = variance;
    newValue.w = leaf;
    g_sourceMipLevelTransmissibility[id] = newValue;
}

[numthreads(8,8,1)]
void ComputeGBufferVariance (uint3 id : SV_DispatchThreadID) {
    ComputeTransmissibilityVariance(id.xy);
}

[numthreads(8,8,1)]
void GenerateGBufferQuadTree (uint3 id : SV_DispatchThreadID) {
    float2 uv = (id.xy + 0.5) / g_target_size;
    for(int i = g_lowest_lod;i >= 0;i--) {
        float4 leaf = g_transmissibility.SampleLevel(samplerg_transmissibility, uv, i);

        if(leaf.w == 1) {
            g_destQuadTreeLeaves[id.xy] = float4(i,0,0,1);
           break;
        }
  }
}
