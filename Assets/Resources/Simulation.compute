#include "../Shaders/PhotonerCommon.cginc"
#include "../Shaders/Random.cginc"
#include "../Shaders/ToneMapping.cginc"
#include "../Shaders/SimulationCommon.cginc"

#pragma multi_compile __ FILTER_INACTIVE_CELLS
#pragma multi_compile __ BILINEAR_PHOTON_DISTRIBUTION

#pragma kernel Simulate_Camera
#pragma kernel Camera_Buffer_Divide
#pragma kernel AccumulatePhotons
#pragma kernel ConvertToHDR
#pragma kernel GenerateOutputMips
#pragma kernel GetCellTransmissibility
#pragma kernel MeasureConvergence
#line 17

RWStructuredBuffer<uint4> g_rand;
RWTexture2D<uint> g_photons_forward;
RWTexture2D<uint> g_output_raw;
RWTexture2D<uint> g_photon_density_raw;

RWTexture2D<float4> g_output_tonemapped;
RWTexture2D<float4> g_previousResult;
RWStructuredBuffer<uint> g_convergenceResult;

Texture2D<float4> g_hdr;
SamplerState samplerg_hdr;
RWTexture2D<float4> g_output_hdr;

struct ConvergenceCellInput {
    uint IsActive;
    uint HasConverged;
    uint FrameCount;
    float TargetTransmission;
    float TransmissionSpread;
    float Reserved[3];
};

struct ConvergenceCellOutput {
    uint MaxValue;
    uint PixelChange;
    uint PhotonCount;
    float Transmissibility;
};

uint4 g_convergenceCells;
RWStructuredBuffer<ConvergenceCellInput> g_convergenceCellStateIn;
RWStructuredBuffer<ConvergenceCellOutput> g_convergenceCellStateOut;

uint g_time_ms;
uint g_photons_per_thread;
uint g_samples_per_pixel;
uint g_density_granularity;
uint2 g_target_size;
float g_energy_norm;
uint g_bounces;
float g_integration_interval;
float g_view_thickness;

uint3 g_lightEnergy;
float g_lightEmissionOutscatter;

float2x3 g_worldToViewport;
float2x3 g_viewportToTarget;
float2x3 g_worldToTarget;
float2x3 g_lightToWorld;
float4x4 g_lightToTarget;

////////////////
// I/O
////////////////

int GetGridCellIndex(uint2 pixel) {
    if(any(pixel >= g_target_size)) {
        return -1;
    } else {
        uint2 cellIndex2D = pixel * g_convergenceCells / g_target_size;
        return (int)(cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x);
    }
}

uint3 ReadForwardPhoton_Indexed(uint2 pixel) {
    uint3 output;

    pixel.x *= 3;
    output.r = g_photons_forward[pixel];
    pixel.x++;
    output.g = g_photons_forward[pixel];
    pixel.x++;
    output.b = g_photons_forward[pixel];
    
    return output;
}

uint3 ReadForwardPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location);
}

void ClearPhoton_Indexed(int2 pixel) {
    pixel.x *= 3;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
}

uint3 ReadPhoton_Indexed(uint2 pixel) {
    uint3 output;
    pixel.x *= 3;
    output.r = g_output_raw[pixel];
    pixel.x++;
    output.g = g_output_raw[pixel];
    pixel.x++;
    output.b = g_output_raw[pixel];
    return output;
}

uint3 ReadPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location);
}

////////////////
// SIMULATION
////////////////

Texture2D<float4> g_lightFieldTexture;
float2 g_directionalLightDirection;

struct BackwardIntegrator : BaseContext, IMonteCarloMethod
{
   // const float backward_integration_interval = 2;
    
    float transmitPotential;
    float quantumScale;
    float currentSample;
    float hitIntensity;
    float uSampleTarget;
    float transmissibility;
    float uSampleRandomOffset;
    float uMax;

    float tested_transmissibility;
    float tested_u;

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;

        hitIntensity = 0;
        transmissibility = 1;

        transmitPotential = 1;
        quantumScale = 1;
        currentSample = 0;
        uSampleTarget = 0;
        uSampleRandomOffset = rand.Next();
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        //ctx.photon.Energy += float3(0,1,0);// g_hdr.SampleLevel(samplerg_hdr, ctx.testUV, 0).rgb;

        uMax = min(ctx.uEscape, 30);
        currentSample = 0;
        uSampleTarget = rand.Next() * g_integration_interval;
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        return tested_u > uMax;
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        while(tested_u > uSampleTarget) {
            currentSample += 1;
            uSampleRandomOffset = rand.Next();
            float4 sample = g_hdr.SampleLevel(samplerg_hdr, ctx.testUV, 0);
            // TODO in the future, a geometry term will be necessary here.
            ctx.photon.Energy += sample.rgb * transmissibility * g_integration_interval / (2 * 3.141592654f * (1 + ctx.uHitCurrent) * (1 + ctx.uHitCurrent));
            //WriteSample(ctx.photon, uSampleTarget, ctx.lod);
            uSampleTarget = (currentSample + uSampleRandomOffset) * g_integration_interval; 
        }

        return true;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        return false;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        // Never gets called since EndTraversal always returns false.
        return true;
    }
};

#define MONTE_CARLO_MODEL BackwardIntegrator
#define INTEGRATOR_NAME Integrate_Backward
#include "Integrate.template.cginc"
#undef INTEGRATOR_NAME
#undef MONTE_CARLO_MODEL

struct SimulationContext : BaseContext {
    float3 SimulateCamera(uint2 xy) {
        float2 origin = xy + 0.5/* + rand.Next2()*/ / g_target_size;
        float2 direction = rand.NextDirection(); // TODO importance sample
        float directional_weight = 1.0;

        float2 uv = origin / g_target_size;
        float3 directLight = g_hdr.SampleLevel(samplerg_hdr, uv, 0).rgb;
        float3 localAlbedo = g_albedo.SampleLevel(sampler_point_clamp, uv, 0).rgb;
        float localTransmissibility = g_transmissibility.SampleLevel(samplerg_transmissibility, origin, 0).x;

        Ray accumulated_photon = {
            origin,
            direction,
            float3(0,0,0)
        };

        BackwardIntegrator integrator;
        integrator.Init(this); 
        Integrate_Backward(accumulated_photon, integrator);
        return accumulated_photon.Energy * localAlbedo /* (1 - pow(localTransmissibility, g_view_thickness))*/ + directLight;
    }
};

[numthreads(NUMTHREADS_2D)]
void Simulate_Camera (uint3 id : SV_DispatchThreadID) {
    uint randContext = id.x + g_target_size.x * id.y;
    SimulationContext sim;
    sim.Init(g_rand[randContext]);
    float3 accumulated_sample = sim.SimulateCamera(id.xy);
    g_rand[randContext] = sim.rand.state;
    g_output_hdr[id.xy] += float4(accumulated_sample, 0);
}

int g_count;
[numthreads(NUMTHREADS_2D)]
void Camera_Buffer_Divide(uint3 id : SV_DispatchThreadID) {
    g_output_hdr[id.xy] = g_hdr[id.xy] / g_count;
}


/////////////////////////
// OUTPUT PROCESSING
/////////////////////////

RWTexture2D<float4> g_output_accumulated;
uint2 g_accumulate_base_index;
[numthreads(NUMTHREADS_2D)]
void AccumulatePhotons(uint3 id : SV_DispatchThreadID)
{
    uint2 index = g_accumulate_base_index + id.xy;
    g_output_accumulated[index] += float4(ReadPhoton_Indexed(index) / g_energy_norm, 1);
    ClearPhoton_Indexed(index);
}

[numthreads(NUMTHREADS_2D)]
void ConvertToHDR (uint3 id : SV_DispatchThreadID) {
    ConvergenceCellInput cellData = g_convergenceCellStateIn[GetGridCellIndex((int2) id.xy)];
    float frames = cellData.FrameCount;

    g_output_hdr[id.xy] = float4((ReadPhoton_Indexed(id.xy) / g_energy_norm + g_output_accumulated[id.xy].rgb) / frames, 1);
}

RWTexture2D<uint> g_sourceMipLevelPhotonCount;
RWTexture2D<float4> g_sourceMipLevelHDR;
RWTexture2D<uint> g_destMipLevelPhotonCount;
RWTexture2D<float4> g_destMipLevelHDR;
[numthreads(NUMTHREADS_2D)]
void GenerateOutputMips(uint3 id : SV_DispatchThreadID) {
    uint2 sourceSize = (uint2)TextureSize(g_sourceMipLevelPhotonCount);
    uint2 destSize = (uint2)TextureSize(g_destMipLevelPhotonCount);

    if (id.x >= destSize.x || id.y >= destSize.y) {
        return;
    }

    uint span_x = 2;
    uint span_y = 2;

    if(id.x == destSize.x - 1 && sourceSize.x % 2 == 1) {
        span_x = 3;
    }

    if(id.y == destSize.y - 1 && sourceSize.y % 2 == 1) {
        span_y = 3;
    }

    uint photons = 0;
    float4 hdr = 0;
    for(uint i = 0; i < span_x; i++) {
        for(uint j = 0; j < span_y; j++) {
            photons += g_sourceMipLevelPhotonCount[id.xy * 2 + uint2(i,j)];
            hdr += g_sourceMipLevelHDR[id.xy * 2 + uint2(i,j)];
        }
    }

    g_destMipLevelPhotonCount[id.xy] = photons;
    g_destMipLevelHDR[id.xy] = hdr / (span_x * span_y);
}

float g_getCellTransmissibility_lod;
[numthreads(NUMTHREADS_2D)]
void GetCellTransmissibility(uint3 id : SV_DispatchThreadID) {
    uint cellIndex = id.y * g_convergenceCells.x + id.x;
    float2 uv = (id.xy + 0.5) / g_convergenceCells;

    g_convergenceCellStateOut[cellIndex].Transmissibility =
        g_transmissibility.SampleLevel(samplerg_transmissibility, uv, g_getCellTransmissibility_lod).x;
}

[numthreads(NUMTHREADS_2D)]
void MeasureConvergence (uint3 id : SV_DispatchThreadID) {
    //const uint EnergyMax = (1 << 31);

    // float4 a = pow(g_output_tonemapped[id.xy], 1/2.2);
    // float4 b = pow(g_previousResult[id.xy], 1/2.2);
    float4 a = g_output_tonemapped[id.xy];
    float4 b = g_previousResult[id.xy];

    uint3 photon = ReadPhoton_Indexed(id.xy);
    uint pixelMax = max(photon.r, max(photon.g, photon.b));

    float4 delta = abs(a - b) * 256;
    uint diff = uint(dot(delta,1) * 100.0);

    uint2 cellIndex2D = id.xy * g_convergenceCells / g_target_size;
    uint cellIndex = cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x;

    InterlockedAdd(g_convergenceCellStateOut[cellIndex].PixelChange, diff);
    InterlockedMax(g_convergenceCellStateOut[cellIndex].MaxValue, pixelMax);
}