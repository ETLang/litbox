#include "../Shaders/RayTracing2DCommon.cginc"
#include "../Shaders/Random.cginc"
#include "../Shaders/ToneMapping.cginc"

#define NUMTHREADS_2D 8,8,1
#define NUMTHREADS_1D 64,1,1

#pragma multi_compile __ FILTER_INACTIVE_CELLS
#pragma multi_compile __ BILINEAR_PHOTON_DISTRIBUTION
#pragma multi_compile __ INTEGRATE_EXPLICIT INTEGRATE_IMPLICIT INTEGRATE_IMPLICIT_INTERVAL INTEGRATE_EXPLICIT_BOUNDED INTEGRATE_EXPLICIT_BOUNCE_IMPLICIT_INTERVAL INTEGRATE_EXPLICIT_BOUNDED_BOUNCE_IMPLICIT_INTERVAL

#pragma kernel Simulate_DefaultLight
#pragma kernel Simulate_PointLight
#pragma kernel Simulate_SpotLight
#pragma kernel Simulate_LaserLight
#pragma kernel Simulate_AmbientLight
#pragma kernel Simulate_FieldLight
#pragma kernel Simulate_DirectionalLight
#pragma kernel AccumulatePhotons
#pragma kernel ConvertToHDR
#pragma kernel GenerateOutputMips
#pragma kernel ToneMap
#pragma kernel GetCellTransmissibility
#pragma kernel MeasureConvergence
#pragma kernel GenerateGBufferMips
#pragma kernel ComputeGBufferVariance
#pragma kernel GenerateGBufferQuadTree

struct Ray {
    float2 Origin;
    float2 Direction;
    float3 Energy;
};

RWStructuredBuffer<uint4> g_rand;
RWTexture2D<uint> g_photons_forward;
RWTexture2D<uint> g_output_raw;
RWTexture2D<uint> g_photon_density_raw;
Texture2D<float4> g_albedo;
Texture2D<float4> g_transmissibility;
SamplerState samplerg_transmissibility;
Texture2D<float4> g_normalAlignment;
SamplerState samplerg_normalAlignment;
Texture2D<float4> g_quadTreeLeaves;

DECLARE_LUT(float2, g_mieScatteringLUT)
DECLARE_LUT(float3, g_teardropScatteringLUT)
DECLARE_LUT_3D(float4, g_bdrfLUT)

RWTexture2D<float4> g_output_tonemapped;
RWTexture2D<float4> g_previousResult;
RWStructuredBuffer<uint> g_convergenceResult;

struct ConvergenceCellInput {
    uint IsActive;
    uint HasConverged;
    uint FrameCount;
    float TargetTransmission;
    float TransmissionSpread;
    float Reserved[3];
};

struct ConvergenceCellOutput {
    uint MaxValue;
    uint PixelChange;
    uint PhotonCount;
    float Transmissibility;
};

uint4 g_convergenceCells;
RWStructuredBuffer<ConvergenceCellInput> g_convergenceCellStateIn;
RWStructuredBuffer<ConvergenceCellOutput> g_convergenceCellStateOut;

uint g_time_ms;
uint g_photons_per_thread;
uint g_samples_per_pixel;
uint g_density_granularity;
uint2 g_target_size;
float g_energy_norm;
uint g_bounces;
float g_mip_test;
uint g_lowest_lod;
uint g_4x4_lod;
float g_path_balance;
float2 g_importance_sampling_target;
float g_integration_interval;

float g_outscatterCoefficient;
uint3 g_lightEnergy;
float g_lightEmissionOutscatter;

float2x3 g_worldToViewport;
float2x3 g_viewportToTarget;
float2x3 g_worldToTarget;
float2x3 g_lightToWorld;
float4x4 g_lightToTarget;

SamplerState sampler_point_clamp;
SamplerState sampler_linear_clamp;

////////////////
// I/O
////////////////

int GetGridCellIndex(uint2 pixel) {
    if(any(pixel >= g_target_size)) {
        return -1;
    } else {
        uint2 cellIndex2D = pixel * g_convergenceCells / g_target_size;
        return (int)(cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x);
    }
}

uint3 ReadForwardPhoton_Indexed(uint2 pixel) {
    uint3 output;

    pixel.x *= 3;
    output.r = g_photons_forward[pixel];
    pixel.x++;
    output.g = g_photons_forward[pixel];
    pixel.x++;
    output.b = g_photons_forward[pixel];
    
    return output;
}

uint3 ReadForwardPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location);
}

void ClearPhoton_Indexed(int2 pixel) {
    pixel.x *= 3;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
}

#define DEBUG_DISABLE_SAFE_WRITES 0
#if DEBUG_DISABLE_SAFE_WRITES
#define InterlockedAdd(dst, value) (dst += value)
#endif

void WritePhoton_Indexed(int2 pixel, uint3 energy, float density, bool suppressPhoton=false) {
    const uint EnergyMax = (1 << 31);

    uint cellIndex = GetGridCellIndex(pixel);

#if FILTER_INACTIVE_CELLS
    if(cellIndex == -1 || !g_convergenceCellStateIn[cellIndex].IsActive) {
        return;
    }
#endif

    if(!suppressPhoton) {
        InterlockedAdd(g_convergenceCellStateOut[cellIndex].PhotonCount, 1);
        if(g_photon_density_raw[pixel] < EnergyMax)
            InterlockedAdd(g_photon_density_raw[pixel], density * g_density_granularity);
    }

    energy *= density;

    pixel.x *= 3;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.r);
    pixel.x++;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.g);
    pixel.x++;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.b);
}

#if DEBUG_DISABLE_SAFE_WRITES
#undef InterlockedAdd
#endif

void WritePhoton_Bilinear(float2 location, uint3 energy, float density, bool suppressPhoton=false) {
    if(any(location < 0)) return;

    float2 pixel = location - 0.5f;
    int2 pixelFloor = (int2)floor(pixel);
    float2 pixelFrac = pixel - pixelFloor;

    WritePhoton_Indexed(pixelFloor, energy, density * (1 - pixelFrac.x) * (1 - pixelFrac.y), suppressPhoton);
    WritePhoton_Indexed(pixelFloor + int2(1, 0), energy, density * pixelFrac.x * (1 - pixelFrac.y), true /*suppressPhoton*/);
    WritePhoton_Indexed(pixelFloor + int2(0, 1), energy, density * (1 - pixelFrac.x) * pixelFrac.y, true /*suppressPhoton*/);
    WritePhoton_Indexed(pixelFloor + int2(1, 1), energy, density * pixelFrac.x * pixelFrac.y, true /*suppressPhoton*/);
}

void WritePhoton(float2 location, uint3 energy, float density, bool suppressPhoton=false) {
#if BILINEAR_PHOTON_DISTRIBUTION
    WritePhoton_Bilinear(location, energy, density, suppressPhoton);
#else
    WritePhoton_Indexed(location, energy, density, suppressPhoton);
#endif
}

uint3 ReadPhoton_Indexed(uint2 pixel) {
    uint3 output;
    pixel.x *= 3;
    output.r = g_output_raw[pixel];
    pixel.x++;
    output.g = g_output_raw[pixel];
    pixel.x++;
    output.b = g_output_raw[pixel];
    return output;
}

uint3 ReadPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location);
}

////////////////
// SIMULATION
////////////////

Texture2D<float4> g_lightFieldTexture;
float2 g_directionalLightDirection;

struct IntegrationContext
{
    Ray photon;
    float uHitCurrent;
    float uHitNext;
    float uEscape;
    float2 testUV;
    float4 transmissibilityCurrent;
    float4 transmissibilityNext;
    int lod;

    void Init(Ray photon) {
        this.photon = photon;
        uHitCurrent = 0;
        uHitNext = 0;
        uEscape = 0;
        testUV = float2(0,0);
        transmissibilityCurrent = float4(1,1,0,0);
        transmissibilityNext = float4(1,1,0,0);
        lod = 0;
    }
};

interface IMonteCarloMethod
{
    // Called when a new raycast begins or after a bounce
    void BeginTraversal(inout IntegrationContext ctx);

    // Called to test for hit condition (overshoot)
    // When testing, the implementation is required to maintain any state necessary for propagation.
    // When Propagate is called, the implementation should update its state to reflect propagation over the tested segment.
    // Returns true upon hit/overshoot, false to continue propagation
    bool Test(inout IntegrationContext ctx);

    // Called to propagate state forward when no hit occurs
    // Returns true to continue propagation, false to abort
    bool Propagate(inout IntegrationContext ctx);

    // Called when raycast ends
    // Once completed, a traversal may alter the photon state in response to, for example, absorption.
    // Returns true if processing should continue, false to abort
    bool EndTraversal(inout IntegrationContext ctx);

    // Called after EndTraversal to adjust photon state for bounces
    bool Bounce(inout IntegrationContext ctx, float3 albedo);
};

struct BaseContext {
    Random rand;

    void Init(uint4 seed) {
        rand.Init(seed);
    }

    void Init(Random r) {
        rand = r;
    }

    float2 ScatterMie(float2 incomingDirection) {
        float2 perp = incomingDirection.yx;
        perp.x *= -1;
    
        float2 scatter = SampleLUT(g_mieScatteringLUT, rand.Next());
        return scatter.x * incomingDirection + scatter.y * perp;
    }
    
    float3 ScatterImportance(float2 origin) {
        float2 important_direction = g_importance_sampling_target - origin;
        float lsq = dot(important_direction, important_direction);
    
        if(false && dot(important_direction, important_direction) < 1/16.0) {
            return float3(rand.NextDirection(), 1);
        } else {
            important_direction /= -sqrt(lsq);
            float2 perp = float2(-important_direction.y, important_direction.x);
            float3 sample = SampleLUT(g_teardropScatteringLUT, rand.Next());
            return float3(important_direction * sample.x + perp * sample.y, sample.z);
        }
    }

    float4 CubicWeights(float u) {
        float4x4 basis = {
            {-0.5,  1.5, -1.5,  0.5},
            {   1, -2.5,    2, -0.5},
            {-0.5,    0,  0.5,    0},
            {   0,    1,    0,    0}
        };

        float uu = u*u;
        float4 series = {uu*u, uu, u, 1};
        return mul(series, basis);
    }

    float4 HermiteWeights(float u) {
        float4x4 basis = {
            { 2,  1, -2,  1},
            {-3, -2,  3, -1},
            { 0,  1,  0,  0},
            { 1,  0,  0,  0}
        };

        float uu = u*u;
        float4 series = {uu*u, uu, u, 1};
        return mul(series, basis);
    }

    float3 BilinearAsCubic(float u) {
        float4 weights = CubicWeights(u);
        float w = weights.x + weights.y;

        return float3(
            /*s = */ weights.x / w - 1 - u,
            /*t = */ weights.z / (1-w) + 1 - u,
            w
        );
    }

    float3 StandardBDRF(float2 normal, float2 reflected, float roughness) {
        float3 uvw = float3(
            rand.Next(),
            (cross2D(normal, reflected) + 1.0) / 2.0,
            roughness);
        float2 tangent = float2(-normal.y, normal.x);

        uint width, height, depth;
        g_bdrfLUT.GetDimensions(width, height, depth);

        float3 rescaled_uvw = {
            dot(float2(1,uvw.x),lut_window_g_bdrfLUT.xy),
            dot(float2(1,uvw.y),lut_window_g_bdrfLUT.zw),
            dot(float2(1,uvw.z),lut_slice_window_g_bdrfLUT)
        };

        float u_in_pixel_space = rescaled_uvw.x * width - 0.5;
        float bilinearParam = frac(u_in_pixel_space);
        float4 weights = CubicWeights(bilinearParam);
        float u_p1 = u_in_pixel_space - bilinearParam;
        float u_p2 = u_p1 + 1;

        float3 uvw_1 = rescaled_uvw;
        uvw_1.x = (u_p1 + 0.5) / width;
        float3 uvw_2 = rescaled_uvw;
        uvw_2.x = (u_p2 + 0.5) / width;

        float4 scattered_1 = g_bdrfLUT.SampleLevel(samplerg_bdrfLUT, uvw_1, 0);
        float4 scattered_2 = g_bdrfLUT.SampleLevel(samplerg_bdrfLUT, uvw_2, 0);

        float4 scattered;

        float4 tangent_1 = float4(-scattered_1.y, scattered_1.x, 0, 0) * scattered_1.z;
        float4 tangent_2 = float4(-scattered_2.y, scattered_2.x, 0, 0) * scattered_2.z;

        float4 hermiteWeights = HermiteWeights(bilinearParam);
        scattered = 
            scattered_1 * hermiteWeights.x +
            tangent_1 * hermiteWeights.y +
            scattered_2 * hermiteWeights.z +
            tangent_2 * hermiteWeights.w;

        //scattered = SampleLUT3D(g_bdrfLUT, uvw);

        return float3(normalize(scattered.x * normal + scattered.y * tangent), scattered.w*scattered.w);
    }
    
    float4 ScatterMaterially(inout float2 origin, float2 origin_uv, float2 incoming)
    {
        const float eps = 1e-5f;
        float4 normal_alignment = g_normalAlignment.SampleLevel(samplerg_normalAlignment, origin_uv, 0);
        float3 normal = normal_alignment.xyz;
        float alignment = normal_alignment.w;

        if(dot(normal.xy, normal.xy) < eps) {
            // No normal information, scatter uniformly
            float2 dir = rand.NextDirection();
            return float4(dir, 1, 0);
        // } else if(dot(normal.xy, normal.xy) < 0.99) {
        //      // Small normal implies we're near a flat surface - continue propagating
        //      return (1).xxxx;
        } else if(dot(normal.xy, incoming) > 0) {
            // Normal is the same general direction as incoming - transmit
            // TODO: Allow the transmission to not count against bounce count.
            // BUG: Setting transmit to 1 causes an infinite loop when photons
            // are emitted within the normal field
            return float4(incoming, 1, /*transmit*/ 1-1);
        } else {
            // TODO: Allow BDRF to operate on not-fully-horizontal normals
            float len = length(normal.xy);
            float2 normal2D = normal.xy / len;
            float2 reflected = reflect(incoming, normal2D);
            
            alignment = saturate(alignment / len);
            origin -= incoming * 2.5;
            if(alignment > 0.999) {
                return float4(reflected, 1, 0);
            } else if(alignment == 0) {
                float2 dir = rand.NextDirection();
                return float4(dot(dir, normal2D) > 0 ? dir : -dir, 1, 0);
            } else {
                float3 scattered = StandardBDRF(normal2D, reflected, 1 - alignment);
                return float4(scattered, 0);
            }
        }
    }

    float4 ScatterMaterially(inout float2 origin, float2 incoming)
    {
        return ScatterMaterially(origin, origin / g_target_size, incoming);
    }
};

struct ImplicitIntegrator : BaseContext, IMonteCarloMethod
{
    float probability;
    float hitIntensity;
    float uTarget;
    float uEscape;
    float transmissibility;

    float tested_transmissibility;
    float tested_u;
        
    void Init(BaseContext ctx)
    {
        rand = ctx.rand;

        probability = 1;
        hitIntensity = 0;
        uTarget = 0;
        transmissibility = 1;
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        this.uEscape = ctx.uEscape;
        uTarget = rand.Next() * ctx.uEscape; // TODO: Find ways to bias this towards important areas
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        return ctx.uHitNext > uTarget;
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        ctx.uHitCurrent = uTarget;
        probability *= transmissibility * uEscape / 256.0; // Downscale to prevent blowout
        hitIntensity = probability * (1 - tested_transmissibility);
        return probability > 1e-9; 
    }
    
    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        ctx.photon.Energy *= albedo;

        //float3 important_direction = ScatterImportance(ctx.photon.Origin);
        float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
        ctx.photon.Direction = important_direction.xy;
        ctx.photon.Energy *= important_direction.z;

        float outScatterDensity  = hitIntensity * important_direction.w;

        WritePhoton(ctx.photon.Origin, ctx.photon.Energy, outScatterDensity, false);//bounce == 0);
       // ctx.photon.Energy -= outScatter;
        return true;
    }
};

struct ImplicitIntervalIntegrator : BaseContext, IMonteCarloMethod
{
    float currentSample;
    float probability;
    float uSampleTarget;
    float uBounceTarget;
    float transmissibility;
    float bounceTransmissibility;

    float tested_transmissibility;
    float tested_u;
    void WriteSample(inout Ray photon, float u, int lod)
    {
        float2 pSample = photon.Origin + photon.Direction * u;
        float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, pSample / g_target_size, 0).rgb;
        float3 outScatterDensity = probability * transmissibility * (1 - pow(tested_transmissibility, 1.0/(1 << lod)));
        WritePhoton(pSample, photon.Energy * albedo, outScatterDensity, false);//bounce == 0);
    }

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;

        probability = 1;
        uBounceTarget = 0;
        transmissibility = 1;
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        currentSample = 0;
        uSampleTarget = rand.Next() * g_integration_interval;
        uBounceTarget = rand.Next() * ctx.uEscape; // TODO: Find ways to bias this towards important areas
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        return tested_u > ctx.uEscape;
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        if(tested_u > uSampleTarget) {
            currentSample += 1;
            WriteSample(ctx.photon, uSampleTarget, ctx.lod);
            uSampleTarget = (currentSample + rand.Next()) * g_integration_interval;
        }

        if(ctx.uHitCurrent < uBounceTarget) {
            bounceTransmissibility = transmissibility;
        } 

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        ctx.uHitCurrent = uBounceTarget;
        transmissibility = bounceTransmissibility;
        probability *= transmissibility;// * ctx.uEscape / 256.0; // Downscale to prevent blowout
        return probability > 1e-7;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        ctx.photon.Energy *= albedo;

        //float3 important_direction = ScatterImportance(photon.Origin);
        float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
        ctx.photon.Direction = important_direction.xy;
        ctx.photon.Energy *= important_direction.z * ctx.uEscape / 256.0;
        return true;
    }
};

struct ExplicitIntegrator : BaseContext, IMonteCarloMethod
{
    float transmissibility;
    float transmitPotential;
    float quantumScale;
    float uEscape;
    
    float4 tested_transmissibility;
    float tested_u;

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;
    }
    
    void BeginTraversal(inout IntegrationContext ctx) 
    {
        this.uEscape = ctx.uEscape;
        transmissibility = 1;

        float u = rand.Next();
        transmitPotential = u * u * u;
        quantumScale = 3 * u * u;
    }

    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext;

        float minimumTransmissibility = ctx.transmissibilityNext.y;
        return minimumTransmissibility * transmissibility < transmitPotential;
    }

    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility.x;
        return true; //ctx.transmissibilityNext.x < ctx.uEscape;
    }

    bool EndTraversal(inout IntegrationContext ctx)
    {
        ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / log2(tested_transmissibility.x);
        return true;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        ctx.photon.Energy *= albedo * quantumScale;

        //float3 important_direction = ScatterImportance(photon.Origin);
        float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
        ctx.photon.Direction = important_direction.xy;
        ctx.photon.Energy *= important_direction.z;

        float outScatterDensity = (1 - tested_transmissibility.x) * important_direction.w;

        WritePhoton(ctx.photon.Origin, ctx.photon.Energy, outScatterDensity, false);//bounce == 0);
        //ctx.photon.Energy -= outScatter;
        return true;
    }
};

struct ExplicitBoundedIntegrator : BaseContext, IMonteCarloMethod
{
    bool searchingPhase;
    float transmissibility;
    float transmitPotential;
    float quantumScale;
    float uEscape;
    
    float4 tested_transmissibility;
    float tested_u;

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;
        searchingPhase = true;
    }
    
    void BeginTraversal(inout IntegrationContext ctx) 
    {
        this.uEscape = ctx.uEscape;
        transmissibility = 1;
    }

    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext;

        if(searchingPhase) {
            return tested_u > ctx.uEscape; 
        } else {
            float minimumTransmissibility = ctx.transmissibilityNext.y;
            return minimumTransmissibility * transmissibility < transmitPotential;
        }
    }

    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility.x;
        return true; //ctx.transmissibilityNext.x < ctx.uEscape;
    }

    bool EndTraversal(inout IntegrationContext ctx)
    {
        if(!searchingPhase) {
            ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / log2(tested_transmissibility.x);
        } else {
            ctx.uHitCurrent = 0;
        }
        return true;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        if(!searchingPhase) {
            ctx.photon.Energy *= albedo * quantumScale;

            //float3 important_direction = ScatterImportance(photon.Origin);
            float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
            ctx.photon.Direction = important_direction.xy;
            ctx.photon.Energy *= important_direction.z;

            float outScatterDensity = (1 - tested_transmissibility.x) * important_direction.w;

            WritePhoton(ctx.photon.Origin, ctx.photon.Energy, outScatterDensity, false);//bounce == 0);
        } else {
            float u = rand.Next(transmissibility, 1);
            transmitPotential = u;
            quantumScale = 1;
            ctx.photon.Energy *= (1 - transmissibility);
            // transmitPotential = u * u * u;
            // quantumScale = 3 * u * u;
        }
        searchingPhase = !searchingPhase;
        return searchingPhase;
    }
};

struct ExplicitBounceImplicitInvervalIntegrator : BaseContext, IMonteCarloMethod
{
    float transmitPotential;
    float quantumScale;
    float currentSample;
    float hitIntensity;
    float uSampleTarget;
    float transmissibility;

    float tested_transmissibility;
    float tested_u;
    void WriteSample(inout Ray photon, float u, int lod)
    {
        float2 pSample = photon.Origin + photon.Direction * u;
        float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, pSample / g_target_size, 0).rgb;
        float outScatterDensity = transmissibility * (1 - pow(tested_transmissibility, 1.0/(1 << lod)));
        WritePhoton(pSample, photon.Energy * albedo, outScatterDensity, false);//bounce == 0);
        photon.Energy -= photon.Energy * albedo * outScatterDensity;
    }

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;

        hitIntensity = 0;
        transmissibility = 1;

        float u = rand.Next();
        transmitPotential = u * u * u;
        quantumScale = 3 * u * u;
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        currentSample = 0;
        uSampleTarget = rand.Next() * g_integration_interval;
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        float minimumTransmissibility = ctx.transmissibilityNext.y;
        return ctx.uHitNext > ctx.uEscape || minimumTransmissibility * transmissibility < transmitPotential;
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        if(tested_u > uSampleTarget) {
            currentSample += 1;
            WriteSample(ctx.photon, uSampleTarget, ctx.lod);
            uSampleTarget = (currentSample + rand.Next()) * g_integration_interval;
        }
        transmissibility *= tested_transmissibility.x;

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return ctx.uHitNext < ctx.uEscape && transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / (log2(tested_transmissibility.x) - 1e-5);
        return true;//probability > 1e-7;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        ctx.photon.Energy *= albedo * quantumScale;

        //float3 important_direction = ScatterImportance(ctx.photon.Origin);
        float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
        ctx.photon.Direction = important_direction.xy;
        ctx.photon.Energy *= important_direction.z;

        return true;
    }
};

struct ExplicitBoundedBounceImplicitInvervalIntegrator : BaseContext, IMonteCarloMethod
{
    bool searchingPhase;
    float transmitPotential;
    float quantumScale;
    float currentSample;
    float hitIntensity;
    float uSampleTarget;
    float transmissibility;
    float uSampleRandomOffset;

    float tested_transmissibility;
    float tested_u;

    void WriteSample(inout Ray photon, float u, int lod)
    {
        float2 pSample = photon.Origin + photon.Direction * u;
        float2 uv = pSample / g_target_size;
        float4 normal_alignment = g_normalAlignment.SampleLevel(samplerg_normalAlignment, uv, 0);

        float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, uv, 0).rgb;
        float outScatterDensity = transmissibility * (1 - pow(tested_transmissibility, 1.0/(1 << lod)));
        WritePhoton(pSample, photon.Energy * albedo, outScatterDensity, false);//bounce == 0);
    }

    void Init(BaseContext ctx)
    {
        searchingPhase = true;
        rand = ctx.rand;

        hitIntensity = 0;
        transmissibility = 1;

        transmitPotential = 1;
        quantumScale = 1;
        currentSample = 0;
        uSampleTarget = 0;
        uSampleRandomOffset = rand.Next();
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        currentSample = 0;
        uSampleTarget = rand.Next() * g_integration_interval;
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        if(searchingPhase) {
            return tested_u > ctx.uEscape; 
        } else {
            float minimumTransmissibility = ctx.transmissibilityNext.y;
            return ctx.uHitNext > ctx.uEscape || minimumTransmissibility * transmissibility < transmitPotential;
        }
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        while(searchingPhase && tested_u > uSampleTarget) {
            currentSample += 1;
            uSampleRandomOffset = rand.Next();
            WriteSample(ctx.photon, uSampleTarget, ctx.lod);
            uSampleTarget = (currentSample + uSampleRandomOffset) * g_integration_interval; 
        }

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return true; //ctx.uHitNext < ctx.uEscape && transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        if(!searchingPhase) {
            ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / (log2(tested_transmissibility.x) - 1e-5);
        } else {
            ctx.uHitCurrent = 0;
        }
        return true;//probability > 1e-7;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        if(!searchingPhase) {
            //float3 important_direction = ScatterImportance(ctx.photon.Origin);
            float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.testUV, ctx.photon.Direction);

            ctx.photon.Energy *= albedo * quantumScale * important_direction.z;
            ctx.photon.Direction = important_direction.xy;
            ctx.photon.Origin += ctx.photon.Direction;

            if(important_direction.w < 0.5) {
                searchingPhase = true;
            } else { // otherwise it's a false bounce. Return to propagating.
                transmissibility /= tested_transmissibility;
            }
        } else {
            float u = rand.Next(transmissibility, 1);
            transmitPotential = u;
            quantumScale = 1-transmissibility;
            searchingPhase = false;
        }
        return searchingPhase;
    }
};

struct SimulationContext : BaseContext {
    Ray EmitPointLight() {
        Ray emitted;
        
        float2 pos = rand.NextCircle();
        
        emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
        
        float3 important_direction = ScatterImportance(emitted.Origin);
        emitted.Direction = important_direction.xy;
        emitted.Energy = g_lightEnergy * important_direction.z;

        return emitted;
    } 

    Ray EmitSpotLight() {
        Ray emitted;

        emitted.Origin = mul(float4(rand.Next()-0.5, rand.Next()-0.5, 0, 1), g_lightToTarget).xy;
        emitted.Direction = normalize(mul(float4(2*rand.Next()-1, -1, 0, 0), g_lightToTarget).xy);
        emitted.Energy = g_lightEnergy;

        return emitted;
    }

    Ray EmitLaserLight() {
        Ray emitted;

        emitted.Origin = mul(float4(rand.Next()-0.5, rand.Next(), 0, 1), g_lightToTarget).xy;
        emitted.Direction = normalize(mul(float4(0,-1,0,0), g_lightToTarget).xy);
        emitted.Energy = g_lightEnergy;

        return emitted;
    }

    Ray EmitAmbientLight() {
        Ray emitted;

        float2 nOrigin = rand.Next2();
        emitted.Origin = nOrigin * g_target_size;
        emitted.Direction = normalize(rand.NextDirection() - (nOrigin * 2 - 1) / 1.44);
        emitted.Energy = g_lightEnergy;

        return emitted;
    }

    Ray EmitFieldLight() {
        Ray emitted;

        float2 uv = rand.Next2();
        float2 pos = uv*2-1;

        float2 _ddx = ddx(g_lightToTarget._m00_m01);
        float2 _ddy = ddy(g_lightToTarget._m10_m11);

        emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
        emitted.Direction = rand.NextDirection();
        float4 texValue = g_lightFieldTexture.SampleGrad(sampler_linear_clamp, uv, _ddx, _ddy);
        texValue.rgb *= (texValue.a - 0.08);
        emitted.Energy = g_lightEnergy * texValue.rgb;

        return emitted;
    }

    Ray EmitDirectionalLight() {
        Ray emitted;

        float2 perp = g_directionalLightDirection.yx;
        perp.y *= -1;
        emitted.Direction = g_directionalLightDirection;

        emitted.Origin = 0.5 - g_directionalLightDirection + perp * (rand.Next() * 1.415 - 0.7075);
        emitted.Origin *= g_target_size;
        emitted.Energy = g_lightEnergy;

        return emitted;
    }

    Ray EmitDefaultLight() {
        Ray emitted;

        emitted.Origin = float2(rand.Next(), 0) * g_target_size;
        emitted.Direction = float2(0,1);
        emitted.Energy = float3(0,1000,0);

        return emitted;
    }

    Ray EmitPath(uint2 pixel) {
        Ray emitted;

        emitted.Origin = ((float2)pixel + rand.Next2()) / (g_target_size - 1);
        float3 important_direction = ScatterImportance(emitted.Origin);
        emitted.Direction = important_direction.xy; // RAND_DIRECTION();
        emitted.Energy = 256.0f * important_direction.zzz;

        return emitted;
    }
    
    // Three flavors of HitTest:
    // - Probabalistic Bounce (implicit)
    // - Packet Intensity (explicit)
    // - Both
    
    /*
    
    Simulation Loop:
    - Hit Test
    - Compute bounce
    - Compute outscatter
    - Write
    
    Hit Test Loop:
    - Iterate over LODs
      - Test (**Injectable)
    - On overshoot (hit) Compute hit metrics (**Injectable) and return
    - Propagate (**Injectable)

    Monte Carlo Sampling Strategies:
    - Implicit Probability Sampling
      - Sample a random uTarget in [0, uEscape]
      - Accumulate transmissibility until overshoot
      - Return hit point, probability = accumulated transmissibility
    - Explicit Probability Sampling
      - Given a packet quantum probability, accumulate transmissibility until packet intensity < accumulated transmissibility

    */

#if INTEGRATE_EXPLICIT
#define MONTE_CARLO_MODEL ExplicitIntegrator
#elif INTEGRATE_IMPLICIT
#define MONTE_CARLO_MODEL ImplicitIntegrator
#elif INTEGRATE_IMPLICIT_INTERVAL
#define MONTE_CARLO_MODEL ImplicitIntervalIntegrator
#elif INTEGRATE_EXPLICIT_BOUNDED
#define MONTE_CARLO_MODEL ExplicitBoundedIntegrator
#elif INTEGRATE_EXPLICIT_BOUNCE_IMPLICIT_INTERVAL
#define MONTE_CARLO_MODEL ExplicitBounceImplicitInvervalIntegrator
#elif INTEGRATE_EXPLICIT_BOUNDED_BOUNCE_IMPLICIT_INTERVAL
#define MONTE_CARLO_MODEL ExplicitBoundedBounceImplicitInvervalIntegrator
#else
#define MONTE_CARLO_MODEL ExplicitBoundedBounceImplicitInvervalIntegrator
#endif

#include "Integrate.template.cginc"

    void SimulateLight(Ray photon) {
        if(g_lightEmissionOutscatter != 0) {
            WritePhoton(photon.Origin, photon.Energy, g_lightEmissionOutscatter, true);
        }

        MONTE_CARLO_MODEL integrator;
        integrator.Init(this);
        Integrate(photon, integrator);
        rand = integrator.rand;
    }
};

SimulationContext CreateSimulationContext(uint4 seed) {
    SimulationContext sim;
    sim.Init(seed);
    return sim;
}

#define SIMULATION_IMPLEMENTATION_LIGHT(lightType)                  \
[numthreads(NUMTHREADS_1D)]                                                \
void Simulate_##lightType (uint3 id : SV_DispatchThreadID) {        \
    SimulationContext sim = CreateSimulationContext(g_rand[id.x]);  \
    sim.SimulateLight(sim.Emit##lightType());                       \
    g_rand[id.x] = sim.rand.state;                                  \
}

#define SIMULATION_IMPLEMENTATION(lightType)        \
    SIMULATION_IMPLEMENTATION_LIGHT(lightType)

SIMULATION_IMPLEMENTATION(DefaultLight)
SIMULATION_IMPLEMENTATION(PointLight)
SIMULATION_IMPLEMENTATION(SpotLight)
SIMULATION_IMPLEMENTATION(LaserLight)
SIMULATION_IMPLEMENTATION(AmbientLight)
SIMULATION_IMPLEMENTATION(FieldLight)
SIMULATION_IMPLEMENTATION(DirectionalLight)


/////////////////////////
// OUTPUT PROCESSING
/////////////////////////

RWTexture2D<float4> g_output_accumulated;
uint2 g_accumulate_base_index;
[numthreads(NUMTHREADS_2D)]
void AccumulatePhotons(uint3 id : SV_DispatchThreadID)
{
    uint2 index = g_accumulate_base_index + id.xy;
    g_output_accumulated[index] += float4(ReadPhoton_Indexed(index) / g_energy_norm, 1);
    ClearPhoton_Indexed(index);
}

RWTexture2D<float4> g_output_hdr;
[numthreads(NUMTHREADS_2D)]
void ConvertToHDR (uint3 id : SV_DispatchThreadID) {
    ConvergenceCellInput cellData = g_convergenceCellStateIn[GetGridCellIndex((int2) id.xy)];
    float frames = cellData.FrameCount;

    g_output_hdr[id.xy] = float4((ReadPhoton_Indexed(id.xy) / g_energy_norm + g_output_accumulated[id.xy].rgb) / frames, 1);
}

RWTexture2D<uint> g_sourceMipLevelPhotonCount;
RWTexture2D<float4> g_sourceMipLevelHDR;
RWTexture2D<uint> g_destMipLevelPhotonCount;
RWTexture2D<float4> g_destMipLevelHDR;
[numthreads(NUMTHREADS_2D)]
void GenerateOutputMips(uint3 id : SV_DispatchThreadID) {
    uint2 sourceSize = (uint2)TextureSize(g_sourceMipLevelPhotonCount);
    uint2 destSize = (uint2)TextureSize(g_destMipLevelPhotonCount);

    if (id.x >= destSize.x || id.y >= destSize.y) {
        return;
    }

    uint span_x = 2;
    uint span_y = 2;

    if(id.x == destSize.x - 1 && sourceSize.x % 2 == 1) {
        span_x = 3;
    }

    if(id.y == destSize.y - 1 && sourceSize.y % 2 == 1) {
        span_y = 3;
    }

    uint photons = 0;
    float4 hdr = 0;
    for(uint i = 0; i < span_x; i++) {
        for(uint j = 0; j < span_y; j++) {
            photons += g_sourceMipLevelPhotonCount[id.xy * 2 + uint2(i,j)];
            hdr += g_sourceMipLevelHDR[id.xy * 2 + uint2(i,j)];
        }
    }

    g_destMipLevelPhotonCount[id.xy] = photons;
    g_destMipLevelHDR[id.xy] = hdr / (span_x * span_y);
}

Texture2D<uint> g_photon_density;
SamplerState samplerg_photon_density;
Texture2D<float4> g_hdr;
SamplerState samplerg_hdr;
float g_exposure;
float3 g_whitePointLog;
float3 g_blackPointLog;

[numthreads(NUMTHREADS_2D)]
void ToneMap (uint3 id : SV_DispatchThreadID) {
    float2 uv = (id.xy + 0.5) / TextureSize(g_output_tonemapped);
    uint2 photonDensityIndex = id.xy;
    uint mipLevel = 0;
    uint2 mipCoord = id.xy;
    float4 hdrValue = g_hdr.SampleLevel(samplerg_hdr, uv, mipLevel);
    uint photonDensity = g_photon_density.Load(uint3(photonDensityIndex, mipLevel)).x;
        
    // Early attempt at adaptive tone mapping based on photon count
    // Results were not good. Recommend using DNN.

    // while(mipLevel < 5) {
    //     hdrValue = g_hdr.SampleLevel(samplerg_hdr, uv, mipLevel);
    //     photonDensity = g_photon_density.Load(uint3(photonDensityIndex, mipLevel)).x;
    //     if(photonDensity > 100) {
    //         break;
    //     }

    //     mipLevel++;
    //     mipCoord /= 2;
    //     photonDensityIndex /= 2;
    // }

    //g_output_tonemapped[id.xy] = float4(ToneMap_UE5(hdrValue.rgb), 1);
    ToneMappingShape_UE5 tone_shape = {
        g_exposure,
        g_whitePointLog,
        g_blackPointLog
    };
    
    g_output_tonemapped[id.xy] = float4(ToneMap_UE5(g_hdr[id.xy], tone_shape), 1);
}

float g_getCellTransmissibility_lod;
[numthreads(NUMTHREADS_2D)]
void GetCellTransmissibility(uint3 id : SV_DispatchThreadID) {
    uint cellIndex = id.y * g_convergenceCells.x + id.x;
    float2 uv = (id.xy + 0.5) / g_convergenceCells;

    g_convergenceCellStateOut[cellIndex].Transmissibility =
        g_transmissibility.SampleLevel(samplerg_transmissibility, uv, g_getCellTransmissibility_lod).x;
}

[numthreads(NUMTHREADS_2D)]
void MeasureConvergence (uint3 id : SV_DispatchThreadID) {
    //const uint EnergyMax = (1 << 31);

    // float4 a = pow(g_output_tonemapped[id.xy], 1/2.2);
    // float4 b = pow(g_previousResult[id.xy], 1/2.2);
    float4 a = g_output_tonemapped[id.xy];
    float4 b = g_previousResult[id.xy];

    uint3 photon = ReadPhoton_Indexed(id.xy);
    uint pixelMax = max(photon.r, max(photon.g, photon.b));

    float4 delta = abs(a - b) * 256;
    uint diff = uint(dot(delta,1) * 100.0);

    uint2 cellIndex2D = id.xy * g_convergenceCells / g_target_size;
    uint cellIndex = cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x;

    InterlockedAdd(g_convergenceCellStateOut[cellIndex].PixelChange, diff);
    InterlockedMax(g_convergenceCellStateOut[cellIndex].MaxValue, pixelMax);
}


/////////////////////////
// G BUFFER PROCESSING
/////////////////////////

RWTexture2D<float4> g_sourceMipLevelAlbedo;
RWTexture2D<float4> g_sourceMipLevelNormalSlope;
RWTexture2D<float4> g_sourceMipLevelTransmissibility;
RWTexture2D<float4> g_destMipLevelAlbedo;
RWTexture2D<float4> g_destMipLevelNormalSlope;
RWTexture2D<float4> g_destMipLevelTransmissibility;
RWTexture2D<float4> g_destQuadTreeLeaves;

float g_TransmissibilityVariationEpsilon;

float4 DownsampleAlbedo(uint2 id) {
    float4 a = g_sourceMipLevelAlbedo[id + uint2(0,0)];
    float4 b = g_sourceMipLevelAlbedo[id + uint2(1,0)];
    float4 c = g_sourceMipLevelAlbedo[id + uint2(0,1)];
    float4 d = g_sourceMipLevelAlbedo[id + uint2(1,1)];

    return (a+b+c+d)/4;
}

float4 DownsampleTransmissibility(uint2 id) {
    float4 a = g_sourceMipLevelTransmissibility[id + uint2(0,0)];
    float4 b = g_sourceMipLevelTransmissibility[id + uint2(1,0)];
    float4 c = g_sourceMipLevelTransmissibility[id + uint2(0,1)];
    float4 d = g_sourceMipLevelTransmissibility[id + uint2(1,1)];

    float at = 1 / (a.x + 1);
    float bt = 1 / (b.x + 1);
    float ct = 1 / (c.x + 1);
    float dt = 1 / (d.x + 1);

    float average = (a.x*b.x + c.x*d.x + a.x*c.x + b.x*d.x) / 4;
    float minimum = min(min(a.y*b.y, c.y*d.y), min(a.y*c.y, b.y*d.y));

    float sr_avg = sqrt(average);
    float4 variances = float4(a.x,b.x,c.x,d.x) - sr_avg;
    variances *= variances;
    float variance = dot(variances, 0.25);
    float leaf = (variance < g_TransmissibilityVariationEpsilon) ? 1 : 0;

    return float4(average, minimum, leaf, 1);
}

float4 DownsampleNormalSlope(uint2 id) {
    float4 a = g_sourceMipLevelNormalSlope[id + uint2(0,0)];
    float4 b = g_sourceMipLevelNormalSlope[id + uint2(1,0)];
    float4 c = g_sourceMipLevelNormalSlope[id + uint2(0,1)];
    float4 d = g_sourceMipLevelNormalSlope[id + uint2(1,1)];

    return float4(normalize(a.xy + b.xy + c.xy + d.xy), (a.zw + b.zw + c.zw + d.zw) / 4);
}

[numthreads(NUMTHREADS_2D)]
void GenerateGBufferMips (uint3 id : SV_DispatchThreadID) {
    g_destMipLevelAlbedo[id.xy] = DownsampleAlbedo(id.xy * 2);
    g_destMipLevelTransmissibility[id.xy] = DownsampleTransmissibility(id.xy * 2);
    g_destMipLevelNormalSlope[id.xy] = DownsampleNormalSlope(id.xy * 2);
}

void ComputeTransmissibilityVariance(uint2 id) {

    float3 r1 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1,-1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0,-1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1,-1)].x
    );
    float3 r2 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1, 0)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0, 0)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1, 0)].x
    );
    float3 r3 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1, 1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0, 1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1, 1)].x
    );

    
    float mean = dot(r1, 1/9.0) + dot(r2, 1/9.0) + dot(r3, 1/9.0);
    
    float3 d1 = r1 - mean;
    float3 d2 = r2 - mean;
    float3 d3 = r3 - mean;

    float variance = sqrt(dot(d1,d1) + dot(d2,d2) + dot(d3,d3)) / 3.0;
    float leaf = (variance < g_TransmissibilityVariationEpsilon) ? 1 : 0;

    float4 newValue = g_sourceMipLevelTransmissibility[id];
    newValue.z = variance;
    newValue.w = leaf;
    g_sourceMipLevelTransmissibility[id] = newValue;
}

[numthreads(NUMTHREADS_2D)]
void ComputeGBufferVariance (uint3 id : SV_DispatchThreadID) {
    ComputeTransmissibilityVariance(id.xy);
}

[numthreads(NUMTHREADS_2D)]
void GenerateGBufferQuadTree (uint3 id : SV_DispatchThreadID) {
    float2 uv = (id.xy + 0.5) / g_target_size;
    for(int i = g_lowest_lod;i >= 0;i--) {
        float4 leaf = g_transmissibility.SampleLevel(samplerg_transmissibility, uv, i);

        if(leaf.w == 1) {
            g_destQuadTreeLeaves[id.xy] = float4(i,0,0,1);
           break;
        }
  }
}
