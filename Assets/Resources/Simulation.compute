#include "../Shaders/RayTracing2DCommon.cginc"
#include "../Shaders/Random.cginc"

#pragma multi_compile __ FILTER_INACTIVE_CELLS
#pragma multi_compile __ BILINEAR_PHOTON_DISTRIBUTION

#pragma kernel Simulate_DefaultLight
#pragma kernel Simulate_PointLight
#pragma kernel Simulate_SpotLight
#pragma kernel Simulate_LaserLight
#pragma kernel Simulate_AmbientLight
#pragma kernel Simulate_FieldLight
#pragma kernel Simulate_DirectionalLight
#pragma kernel AccumulatePhotons
#pragma kernel ConvertToHDR
#pragma kernel ToneMap
#pragma kernel GetCellTransmissibility
#pragma kernel MeasureConvergence
#pragma kernel GenerateGBufferMips
#pragma kernel ComputeGBufferVariance
#pragma kernel GenerateGBufferQuadTree

struct Ray {
    float2 Origin;
    float2 Direction;
    uint3 Energy;
    float FineScale;
};

RWStructuredBuffer<uint4> g_rand;
RWTexture2D<uint> g_photons_forward;
RWTexture2D<uint> g_output_raw;
Texture2D<float4> g_albedo;
Texture2D<float4> g_transmissibility;
SamplerState samplerg_transmissibility;
Texture2D<float4> g_normalAlignment;
SamplerState samplerg_normalAlignment;
Texture2D<float4> g_quadTreeLeaves;

DECLARE_LUT(float2, g_mieScatteringLUT)
DECLARE_LUT(float3, g_teardropScatteringLUT)
DECLARE_LUT_3D(float2, g_quantumTunnelingLUT)

RWTexture2D<float4> g_output_tonemapped;
RWTexture2D<float4> g_previousResult;
RWStructuredBuffer<uint> g_convergenceResult;

struct ConvergenceCellInput {
    uint IsActive;
    uint HasConverged;
    uint FrameCount;
    float TargetTransmission;
    float TransmissionSpread;
    float Reserved[3];
};

struct ConvergenceCellOutput {
    uint MaxValue;
    uint PixelChange;
    uint PhotonCount;
    float Transmissibility;
};

uint4 g_convergenceCells;
RWStructuredBuffer<ConvergenceCellInput> g_convergenceCellStateIn;
RWStructuredBuffer<ConvergenceCellOutput> g_convergenceCellStateOut;

uint g_time_ms;
uint g_photons_per_thread;
uint g_samples_per_pixel;
uint2 g_target_size;
float g_energy_norm;
uint g_bounces;
float g_mip_test;
uint g_lowest_lod;
uint g_4x4_lod;
float g_path_balance;
float2 g_importance_sampling_target;

float g_outscatterCoefficient;
uint3 g_lightEnergy;
float g_lightEmissionOutscatter;

float2x3 g_worldToViewport;
float2x3 g_viewportToTarget;
float2x3 g_worldToTarget;
float2x3 g_lightToWorld;
float4x4 g_lightToTarget;

SamplerState sampler_point_clamp;
SamplerState sampler_linear_clamp;

////////////////
// I/O
////////////////

int GetGridCellIndex(uint2 pixel) {
    if(any(pixel >= g_target_size)) {
        return -1;
    } else {
        uint2 cellIndex2D = pixel * g_convergenceCells / g_target_size;
        return (int)(cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x);
    }
}

uint3 ReadForwardPhoton_Indexed(uint2 pixel) {
    uint3 output;

    pixel.x *= 3;
    output.r = g_photons_forward[pixel];
    pixel.x++;
    output.g = g_photons_forward[pixel];
    pixel.x++;
    output.b = g_photons_forward[pixel];
    
    return output;
}

uint3 ReadForwardPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location);
}

void ClearPhoton_Indexed(int2 pixel) {
    pixel.x *= 3;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
    pixel.x++;
    g_output_raw[pixel] = 0;
}

void WritePhoton_Indexed(int2 pixel, uint3 energy, bool suppressPhoton=false) {
    const uint EnergyMax = (1 << 31);

    uint cellIndex = GetGridCellIndex(pixel);

#if FILTER_INACTIVE_CELLS
    if(cellIndex == -1 || !g_convergenceCellStateIn[cellIndex].IsActive) {
        return;
    }
#endif

    if(!suppressPhoton) {
        InterlockedAdd(g_convergenceCellStateOut[cellIndex].PhotonCount, 1);
    }

    pixel.x *= 3;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.r);
    pixel.x++;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.g);
    pixel.x++;
    if(g_output_raw[pixel] < EnergyMax)
        InterlockedAdd(g_output_raw[pixel], energy.b);
}

void WritePhoton_Bilinear(float2 location, uint3 energy, bool suppressPhoton=false) {
    if(any(location < 0)) return;

    float2 pixel = location - 0.5f;
    int2 pixelFloor = (int2)floor(pixel);
    float2 pixelFrac = pixel - pixelFloor;

    WritePhoton_Indexed(pixelFloor, energy * (1 - pixelFrac.x) * (1 - pixelFrac.y), suppressPhoton);
    WritePhoton_Indexed(pixelFloor + int2(1, 0), energy * pixelFrac.x * (1 - pixelFrac.y), true /*suppressPhoton*/);
    WritePhoton_Indexed(pixelFloor + int2(0, 1), energy * (1 - pixelFrac.x) * pixelFrac.y, true /*suppressPhoton*/);
    WritePhoton_Indexed(pixelFloor + int2(1, 1), energy * pixelFrac.x * pixelFrac.y, true /*suppressPhoton*/);
}

void WritePhoton(float2 location, uint3 energy, bool suppressPhoton=false) {
#if BILINEAR_PHOTON_DISTRIBUTION
    WritePhoton_Bilinear(location, energy, suppressPhoton);
#else
    WritePhoton_Indexed(location, energy, suppressPhoton);
#endif
}

uint3 ReadPhoton_Indexed(uint2 pixel) {
    uint3 output;
    pixel.x *= 3;
    output.r = g_output_raw[pixel];
    pixel.x++;
    output.g = g_output_raw[pixel];
    pixel.x++;
    output.b = g_output_raw[pixel];
    return output;
}

uint3 ReadPhoton(float2 location) {
    return ReadForwardPhoton_Indexed(location);
}

////////////////
// SIMULATION
////////////////

Texture2D<float4> g_lightFieldTexture;
float2 g_directionalLightDirection;

struct IntegrationContext
{
    Ray photon;
    float uHitCurrent;
    float uHitNext;
    float uEscape;
    float4 transmissibilityCurrent;
    float4 transmissibilityNext;
    int lod;

    void Init(Ray photon) {
        this.photon = photon;
        uHitCurrent = 0;
        uHitNext = 0;
        uEscape = 0;
        transmissibilityCurrent = float4(1,1,0,0);
        transmissibilityNext = float4(1,1,0,0);
        lod = 0;
    }
};

interface IMonteCarloMethod
{
    // Called when a new raycast begins or after a bounce
    void BeginTraversal(inout IntegrationContext ctx);

    // Called to test for hit condition (overshoot)
    // When testing, the implementation is required to maintain any state necessary for propagation.
    // When Propagate is called, the implementation should update its state to reflect propagation over the tested segment.
    // Returns true upon hit/overshoot, false to continue propagation
    bool Test(inout IntegrationContext ctx);

    // Called to propagate state forward when no hit occurs
    // Returns true to continue propagation, false to abort
    bool Propagate(inout IntegrationContext ctx);

    // Called when raycast ends
    // Once completed, a traversal may alter the photon state in response to, for example, absorption.
    // Returns true if processing should continue, false to abort
    bool EndTraversal(inout IntegrationContext ctx);

    // Called after EndTraversal to adjust photon state for bounces
    bool Bounce(inout IntegrationContext ctx, float3 albedo);
};

struct BaseContext {
    Random rand;

    void Init(uint4 seed) {
        rand.Init(seed);
    }

    void Init(Random r) {
        rand = r;
    }

    float2 ScatterMie(float2 incomingDirection) {
        float2 perp = incomingDirection.yx;
        perp.x *= -1;
    
        float2 scatter = SampleLUT(g_mieScatteringLUT, rand.Next());
        return scatter.x * incomingDirection + scatter.y * perp;
    }
    
    float3 ScatterImportance(float2 origin) {
        float2 important_direction = g_importance_sampling_target - origin;
        float lsq = dot(important_direction, important_direction);
    
        if(false && dot(important_direction, important_direction) < 1/16.0) {
            return float3(rand.NextDirection(), 1);
        } else {
            important_direction /= -sqrt(lsq);
            float2 perp = float2(-important_direction.y, important_direction.x);
            float3 sample = SampleLUT(g_teardropScatteringLUT, rand.Next());
            return float3(important_direction * sample.x + perp * sample.y, sample.z);
        }
    }
    
    float4 ScatterMaterially(float2 origin, float2 origin_uv, float2 incoming)
    {
        const float eps = 1e-5f;
        float4 normal_alignment = g_normalAlignment.SampleLevel(samplerg_normalAlignment, origin_uv, 0);
        float3 normal = normal_alignment.xyz;
        float alignment = normal_alignment.w; 
        float3 incident = reflect(float3(incoming, 0), normal);
        float2 dir = normalize(rand.NextDirection() + incident.xy / (1 - alignment + eps));
        return float4(dir, 1, dot(normal.xy, normal.xy) > 0 ? 0 : 1);
    }

    float4 ScatterMaterially(float2 origin, float2 incoming)
    {
        return ScatterMaterially(origin, origin / g_target_size, incoming);
    }
};

struct ImplicitIntegrator : BaseContext, IMonteCarloMethod
{
    float probability;
    float hitIntensity;
    float uTarget;
    float uEscape;
    float transmissibility;

    float tested_transmissibility;
    float tested_u;
        
    void Init(BaseContext ctx)
    {
        rand = ctx.rand;

        probability = 1;
        hitIntensity = 0;
        uTarget = 0;
        transmissibility = 1;
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        this.uEscape = ctx.uEscape;
        uTarget = rand.Next() * ctx.uEscape; // TODO: Find ways to bias this towards important areas
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        return ctx.uHitNext > uTarget;
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        ctx.uHitCurrent = uTarget;
        probability *= transmissibility * uEscape / 256.0; // Downscale to prevent blowout
        hitIntensity = probability * (1 - tested_transmissibility);
        //photon.FineScale *= hitIntensity;
        return probability > 1e-9; 
    }
    
    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
#if USE_ORIGINAL_HIT_TEST
        ctx.photon.Energy *= albedo * quantumScale;
#else
        ctx.photon.Energy *= albedo;
#endif

        //float3 important_direction = ScatterImportance(ctx.photon.Origin);
        float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
        ctx.photon.Direction = important_direction.xy;
        ctx.photon.FineScale *= important_direction.z;

#if USE_ORIGINAL_HIT_TEST
        uint3 outScatter = ctx.photon.Energy * g_outscatterCoefficient;
#else
        uint3 outScatter = ctx.photon.Energy * hitIntensity;
#endif
        outScatter *= important_direction.w;

        WritePhoton(ctx.photon.Origin, outScatter * ctx.photon.FineScale, false);//bounce == 0);
        ctx.photon.Energy -= outScatter;
        return true;
    }
};

#define SAMPLE_INTERVAL 50.0f
struct ImplicitIntervalIntegrator : BaseContext, IMonteCarloMethod
{
    float currentSample;
    float probability;
    float hitIntensity;
    float uSampleTarget;
    float uBounceTarget;
    float transmissibility;

    float tested_transmissibility;
    float tested_u;
    void WriteSample(inout Ray photon, float u, int lod)
    {
        float2 pSample = photon.Origin + photon.Direction * u;
        float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, pSample / g_target_size, 0).rgb;
        uint3 outScatter = photon.Energy * albedo * probability * transmissibility * (1 - pow(tested_transmissibility, 1.0/(1 << lod)));
        WritePhoton(pSample, outScatter * photon.FineScale, false);//bounce == 0);
        photon.Energy -= outScatter;
    }

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;

        probability = 1;
        hitIntensity = 0;
        uBounceTarget = 0;
        transmissibility = 1;
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        currentSample = 0;
        uSampleTarget = rand.Next() * SAMPLE_INTERVAL;
        uBounceTarget = rand.Next() * ctx.uEscape; // TODO: Find ways to bias this towards important areas
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        return tested_u > uBounceTarget;
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        if(tested_u > uSampleTarget) {
            currentSample += 1;
            WriteSample(ctx.photon, uSampleTarget, ctx.lod);
            uSampleTarget = (currentSample + rand.Next()) * SAMPLE_INTERVAL;
        }

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        ctx.uHitCurrent = uBounceTarget;
        probability *= transmissibility * ctx.uEscape / 256.0; // Downscale to prevent blowout
        //hitIntensity = probability * (1 - tested_transmissibility);
        //photon.FineScale *= hitIntensity;
        return probability > 1e-7;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        ctx.photon.Energy *= albedo;

        //float3 important_direction = ScatterImportance(photon.Origin);
        float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
        ctx.photon.Direction = important_direction.xy;
        ctx.photon.FineScale *= important_direction.z;

        uint3 outScatter = ctx.photon.Energy * probability * (1 - tested_transmissibility);
        outScatter *= important_direction.w;
        //WritePhoton(photon.Origin, outScatter * photon.FineScale, false);//bounce == 0);
        ctx.photon.Energy -= outScatter;
        return true;
    }
};

struct ExplicitIntegrator : BaseContext, IMonteCarloMethod
{
    float transmissibility;
    float transmitPotential;
    float quantumScale;
    float uEscape;
    
    float4 tested_transmissibility;
    float tested_u;

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;
    }
    
    void BeginTraversal(inout IntegrationContext ctx) 
    {
        this.uEscape = ctx.uEscape;
        transmissibility = 1;

        float u = rand.Next();
        transmitPotential = u * u * u;
        quantumScale = 3 * u * u;
    }

    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext;

        float minimumTransmissibility = ctx.transmissibilityNext.y;
        return minimumTransmissibility * transmissibility < transmitPotential;
    }

    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility.x;
        return true; //ctx.transmissibilityNext.x < ctx.uEscape;
    }

    bool EndTraversal(inout IntegrationContext ctx)
    {
        ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / log2(tested_transmissibility.x);
        return true;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        ctx.photon.Energy *= albedo * quantumScale;

        //float3 important_direction = ScatterImportance(photon.Origin);
        float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
        ctx.photon.Direction = important_direction.xy;
        ctx.photon.FineScale *= important_direction.z;

        uint3 outScatter = ctx.photon.Energy * (1 - tested_transmissibility.x);

        outScatter *= important_direction.w;

        WritePhoton(ctx.photon.Origin, outScatter * ctx.photon.FineScale, false);//bounce == 0);
        ctx.photon.Energy -= outScatter;
        return true;
    }
};

struct ExplicitBoundedIntegrator : BaseContext, IMonteCarloMethod
{
    bool searchingPhase;
    float transmissibility;
    float transmitPotential;
    float quantumScale;
    float uEscape;
    
    float4 tested_transmissibility;
    float tested_u;

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;
        searchingPhase = true;
    }
    
    void BeginTraversal(inout IntegrationContext ctx) 
    {
        this.uEscape = ctx.uEscape;
        transmissibility = 1;
    }

    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext;

        if(searchingPhase) {
            return tested_u > ctx.uEscape; 
        } else {
            float minimumTransmissibility = ctx.transmissibilityNext.y;
            return minimumTransmissibility * transmissibility < transmitPotential;
        }
    }

    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility.x;
        return true; //ctx.transmissibilityNext.x < ctx.uEscape;
    }

    bool EndTraversal(inout IntegrationContext ctx)
    {
        if(!searchingPhase) {
            ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / log2(tested_transmissibility.x);
        } else {
            ctx.uHitCurrent = 0;
        }
       // WritePhoton(ctx.photon.Origin, uint3(100000, 0, 0) * ctx.photon.FineScale, false);//bounce == 0);
        return true;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        if(!searchingPhase) {
            ctx.photon.Energy *= albedo * quantumScale;

            //float3 important_direction = ScatterImportance(photon.Origin);
            float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
            ctx.photon.Direction = important_direction.xy;
            ctx.photon.FineScale *= important_direction.z;

            uint3 outScatter = ctx.photon.Energy * (1 - tested_transmissibility.x);

            outScatter *= important_direction.w;

            WritePhoton(ctx.photon.Origin, outScatter * ctx.photon.FineScale, false);//bounce == 0);
            ctx.photon.Energy -= outScatter;
        } else {
            float u = rand.Next(transmissibility, 1);
            transmitPotential = u;
            quantumScale = 1;
            ctx.photon.FineScale *= (1 - transmissibility);
            // transmitPotential = u * u * u;
            // quantumScale = 3 * u * u;
        }
        searchingPhase = !searchingPhase;
        return searchingPhase;
    }
};

struct ExplicitBounceImplicitInvervalIntegrator : BaseContext, IMonteCarloMethod
{
    float transmitPotential;
    float quantumScale;
    float currentSample;
    //float probability;
    float hitIntensity;
    float uSampleTarget;
   // float uBounceTarget;
    float transmissibility;

    float tested_transmissibility;
    float tested_u;
    void WriteSample(inout Ray photon, float u, int lod)
    {
        float2 pSample = photon.Origin + photon.Direction * u;
        float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, pSample / g_target_size, 0).rgb;
        uint3 outScatter = photon.Energy * albedo * /*probability */ transmissibility * (1 - pow(tested_transmissibility, 1.0/(1 << lod)));
        WritePhoton(pSample, outScatter * photon.FineScale, false);//bounce == 0);
        photon.Energy -= outScatter;
    }

    void Init(BaseContext ctx)
    {
        rand = ctx.rand;

       // probability = 1;
        hitIntensity = 0;
       // uBounceTarget = 0;
        transmissibility = 1;

        float u = rand.Next();
        // transmitPotential = 1;
        // quantumScale = 1;
        transmitPotential = u * u * u;
        quantumScale = 3 * u * u;
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        currentSample = 0;
        uSampleTarget = rand.Next() * SAMPLE_INTERVAL;
       // uBounceTarget = rand.Next() * ctx.uEscape; // TODO: Find ways to bias this towards important areas
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        float minimumTransmissibility = ctx.transmissibilityNext.y;
        return ctx.uHitNext > ctx.uEscape || minimumTransmissibility * transmissibility < transmitPotential;
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        if(tested_u > uSampleTarget) {
            currentSample += 1;
            WriteSample(ctx.photon, uSampleTarget, ctx.lod);
            uSampleTarget = (currentSample + rand.Next()) * SAMPLE_INTERVAL;
        }
        transmissibility *= tested_transmissibility.x;
       // return true; //ctx.transmissibilityNext.x < ctx.uEscape;

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return ctx.uHitNext < ctx.uEscape && transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
       // probability *= transmissibility * ctx.uEscape / 256.0; // Downscale to prevent blowout
        ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / log2(tested_transmissibility.x);
        //hitIntensity = probability * (1 - tested_transmissibility);
        //photon.FineScale *= hitIntensity;
        return true;//probability > 1e-7;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        ctx.photon.Energy *= albedo * quantumScale;

        float3 important_direction = ScatterImportance(ctx.photon.Origin);
        // float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
        ctx.photon.Direction = important_direction.xy;
        ctx.photon.FineScale *= important_direction.z;

       // uint3 outScatter = ctx.photon.Energy * probability * (1 - tested_transmissibility);
       // outScatter *= important_direction.w;
        //WritePhoton(photon.Origin, outScatter * photon.FineScale, false);//bounce == 0);
       // ctx.photon.Energy -= outScatter;
        return true;
    }
};

struct ExplicitBoundedBounceImplicitInvervalIntegrator : BaseContext, IMonteCarloMethod
{
    bool searchingPhase;
    float transmitPotential;
    float quantumScale;
    float currentSample;
    float hitIntensity;
    float uSampleTarget;
    float transmissibility;

    float tested_transmissibility;
    float tested_u;
    void WriteSample(inout Ray photon, float u, int lod)
    {
        float2 pSample = photon.Origin + photon.Direction * u;
        float3 albedo = g_albedo.SampleLevel(sampler_point_clamp, pSample / g_target_size, 0).rgb;
        uint3 outScatter = photon.Energy * albedo * transmissibility * (1 - pow(tested_transmissibility, 1.0/(1 << lod)));
        WritePhoton(pSample, outScatter * photon.FineScale, false);//bounce == 0);
        photon.Energy -= outScatter;
    }

    void Init(BaseContext ctx)
    {
        searchingPhase = true;
        rand = ctx.rand;

        hitIntensity = 0;
        transmissibility = 1;

        transmitPotential = 1;
        quantumScale = 1;
        currentSample = 0;
        uSampleTarget = 0;
    }

    void BeginTraversal(inout IntegrationContext ctx)
    {
        currentSample = 0;
        uSampleTarget = rand.Next() * SAMPLE_INTERVAL;
        transmissibility = 1;
    }
    
    bool Test(inout IntegrationContext ctx)
    {
        tested_u = ctx.uHitNext;
        tested_transmissibility = ctx.transmissibilityNext.x;

        if(searchingPhase) {
            return tested_u > ctx.uEscape; 
        } else {
            float minimumTransmissibility = ctx.transmissibilityNext.y;
            return ctx.uHitNext > ctx.uEscape || minimumTransmissibility * transmissibility < transmitPotential;
        }
    }
    
    bool Propagate(inout IntegrationContext ctx)
    {
        transmissibility *= tested_transmissibility;

        if(tested_u > uSampleTarget) {
            currentSample += 1;
            WriteSample(ctx.photon, uSampleTarget, ctx.lod);
            uSampleTarget = (currentSample + rand.Next()) * SAMPLE_INTERVAL;
        }
        transmissibility *= tested_transmissibility.x;

        // If the density of the substrate is too high, consider this the new endpoint.
        //THIS CONDITION WILL BREAK REFLECTION WHEN DENSITY APPROACHES 1
        return true; //ctx.uHitNext < ctx.uEscape && transmissibility > 1e-9;
    }
    
    bool EndTraversal(inout IntegrationContext ctx)
    {
        if(!searchingPhase) {
            ctx.uHitCurrent = tested_u + log2(transmitPotential / transmissibility) / (log2(tested_transmissibility.x) - 1e-5);
        } else {
            ctx.uHitCurrent = 0;
        }
        return true;//probability > 1e-7;
    }

    bool Bounce(inout IntegrationContext ctx, float3 albedo)
    {
        if(!searchingPhase) {
            ctx.photon.Energy *= albedo * quantumScale;

            //float3 important_direction = ScatterImportance(ctx.photon.Origin);
            float4 important_direction = ScatterMaterially(ctx.photon.Origin, ctx.photon.Direction);
            ctx.photon.Direction = important_direction.xy;
            ctx.photon.FineScale *= important_direction.z;
            return true;
        } else {
            float u = rand.Next(transmissibility, 1);
            transmitPotential = u;
            quantumScale = 1;
            //transmitPotential = u * u * u;
            //quantumScale = 3 * u * u;
        }
        searchingPhase = !searchingPhase;
        return searchingPhase;
    }
};

struct SimulationContext : BaseContext {
    Ray EmitPointLight() {
        Ray emitted;
        
        float2 pos = rand.NextCircle();
        
        emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
        
        float3 important_direction = ScatterImportance(emitted.Origin);
        emitted.Direction = important_direction.xy;
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = important_direction.z;

        return emitted;
    } 

    Ray EmitSpotLight() {
        Ray emitted;

        emitted.Origin = mul(float4(rand.Next()-0.5, rand.Next()-0.5, 0, 1), g_lightToTarget).xy;
        emitted.Direction = normalize(mul(float4(2*rand.Next()-1, -1, 0, 0), g_lightToTarget).xy);
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitLaserLight() {
        Ray emitted;

        emitted.Origin = mul(float4(rand.Next()-0.5, rand.Next(), 0, 1), g_lightToTarget).xy;
        emitted.Direction = normalize(mul(float4(0,-1,0,0), g_lightToTarget).xy);
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitAmbientLight() {
        Ray emitted;

        float2 nOrigin = rand.Next2();
        emitted.Origin = nOrigin * g_target_size;
        emitted.Direction = normalize(rand.NextDirection() - (nOrigin * 2 - 1) / 1.44);
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitFieldLight() {
        Ray emitted;

        float2 uv = rand.Next2();
        float2 pos = uv*2-1;

        float2 _ddx = ddx(g_lightToTarget._m00_m01);
        float2 _ddy = ddy(g_lightToTarget._m10_m11);

        emitted.Origin = mul(float4(pos, 0, 1), g_lightToTarget).xy;
        emitted.Direction = rand.NextDirection();
        float4 texValue = g_lightFieldTexture.SampleGrad(sampler_linear_clamp, uv, _ddx, _ddy);
        texValue.rgb *= (texValue.a - 0.08);
        emitted.Energy = g_lightEnergy * texValue.rgb;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitDirectionalLight() {
        Ray emitted;

        float2 perp = g_directionalLightDirection.yx;
        perp.y *= -1;
        emitted.Direction = g_directionalLightDirection;

        emitted.Origin = 0.5 - g_directionalLightDirection + perp * (rand.Next() * 1.415 - 0.7075);
        emitted.Origin *= g_target_size;
        emitted.Energy = g_lightEnergy;
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitDefaultLight() {
        Ray emitted;

        emitted.Origin = float2(rand.Next(), 0) * g_target_size;
        emitted.Direction = float2(0,1);
        emitted.Energy = float3(0,1000,0);
        emitted.FineScale = 1;

        return emitted;
    }

    Ray EmitPath(uint2 pixel) {
        Ray emitted;

        emitted.Origin = ((float2)pixel + rand.Next2()) / (g_target_size - 1);
        float3 important_direction = ScatterImportance(emitted.Origin);
        emitted.Direction = important_direction.xy; // RAND_DIRECTION();
        emitted.FineScale = important_direction.z;
        emitted.Energy = uint3(256,256,256);

        return emitted;
    }
    
    // Three flavors of HitTest:
    // - Probabalistic Bounce (implicit)
    // - Packet Intensity (explicit)
    // - Both
    
    /*
    
    Simulation Loop:
    - Hit Test
    - Compute bounce
    - Compute outscatter
    - Write
    
    Hit Test Loop:
    - Iterate over LODs
      - Test (**Injectable)
    - On overshoot (hit) Compute hit metrics (**Injectable) and return
    - Propagate (**Injectable)

    Monte Carlo Sampling Strategies:
    - Implicit Probability Sampling
      - Sample a random uTarget in [0, uEscape]
      - Accumulate transmissibility until overshoot
      - Return hit point, probability = accumulated transmissibility
    - Explicit Probability Sampling
      - Given a packet quantum probability, accumulate transmissibility until packet intensity < accumulated transmissibility

    */
// #define MONTE_CARLO_MODEL ImplicitIntegrator
// #define MONTE_CARLO_MODEL ImplicitIntervalIntegrator
// #define MONTE_CARLO_MODEL ExplicitIntegrator
//#define MONTE_CARLO_MODEL ExplicitBoundedIntegrator
// #define MONTE_CARLO_MODEL ExplicitBounceImplicitInvervalIntegrator
#define MONTE_CARLO_MODEL ExplicitBoundedBounceImplicitInvervalIntegrator
// #define MONTE_CARLO_MODEL HybridIntegrator
#include "Integrate.template.cginc"

    void SimulateLight(Ray photon) {
        if(g_lightEmissionOutscatter != 0) {
            uint3 emissionOutscatter = photon.Energy * g_lightEmissionOutscatter;
            WritePhoton(photon.Origin, emissionOutscatter, true);
        }

        MONTE_CARLO_MODEL integrator;
        integrator.Init(this);
        Integrate(photon, integrator);
        rand = integrator.rand;
    }
};

SimulationContext CreateSimulationContext(uint4 seed) {
    SimulationContext sim;
    sim.Init(seed);
    return sim;
}

#define SIMULATION_IMPLEMENTATION_LIGHT(lightType)                  \
[numthreads(64,1,1)]                                                \
void Simulate_##lightType (uint3 id : SV_DispatchThreadID) {        \
    SimulationContext sim = CreateSimulationContext(g_rand[id.x]);  \
    sim.SimulateLight(sim.Emit##lightType());                       \
    g_rand[id.x] = sim.rand.state;                                  \
}

#define SIMULATION_IMPLEMENTATION(lightType)        \
    SIMULATION_IMPLEMENTATION_LIGHT(lightType)

SIMULATION_IMPLEMENTATION(DefaultLight)
SIMULATION_IMPLEMENTATION(PointLight)
SIMULATION_IMPLEMENTATION(SpotLight)
SIMULATION_IMPLEMENTATION(LaserLight)
SIMULATION_IMPLEMENTATION(AmbientLight)
SIMULATION_IMPLEMENTATION(FieldLight)
SIMULATION_IMPLEMENTATION(DirectionalLight)


/////////////////////////
// OUTPUT PROCESSING
/////////////////////////

RWTexture2D<float4> g_output_accumulated;
uint2 g_accumulate_base_index;
[numthreads(8, 8, 1)]
void AccumulatePhotons(uint3 id : SV_DispatchThreadID)
{
    uint2 index = g_accumulate_base_index + id.xy;
    g_output_accumulated[index] += float4(ReadPhoton_Indexed(index) / g_energy_norm, 1);
    ClearPhoton_Indexed(index);
}

RWTexture2D<float4> g_output_hdr;
[numthreads(8,8,1)]
void ConvertToHDR (uint3 id : SV_DispatchThreadID) {
    ConvergenceCellInput cellData = g_convergenceCellStateIn[GetGridCellIndex((int2) id.xy)];
    float frames = cellData.FrameCount;

    g_output_hdr[id.xy] = float4((ReadPhoton_Indexed(id.xy) / g_energy_norm + g_output_accumulated[id.xy].rgb) / frames, 1);
}

float3 ToneMap_ApproximationA(float3 x) {
    x = max(0, x - 0.004);
    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);
}

[numthreads(8,8,1)]
void ToneMap (uint3 id : SV_DispatchThreadID) {
    ConvergenceCellInput cellData = g_convergenceCellStateIn[GetGridCellIndex((int2) id.xy)];
    
    //g_output_tonemapped[id.xy] = float4(ToneMap_ApproximationA(output.rgb), 1);
    g_output_tonemapped[id.xy] = float4(smoothstep(-4, 2, log10(g_output_hdr[id.xy].rgb)), 1); // bit silly but... works?

    if(!cellData.IsActive) {
        g_output_tonemapped[id.xy] *= float4(1,0.6,0.6,1);
    }
}

float g_getCellTransmissibility_lod;
[numthreads(8,8,1)]
void GetCellTransmissibility(uint3 id : SV_DispatchThreadID) {
    uint cellIndex = id.y * g_convergenceCells.x + id.x;
    float2 uv = (id.xy + 0.5) / g_convergenceCells;

    g_convergenceCellStateOut[cellIndex].Transmissibility =
        g_transmissibility.SampleLevel(samplerg_transmissibility, uv, g_getCellTransmissibility_lod).x;
}

[numthreads(8,8,1)]
void MeasureConvergence (uint3 id : SV_DispatchThreadID) {
    //const uint EnergyMax = (1 << 31);

    // float4 a = pow(g_output_tonemapped[id.xy], 1/2.2);
    // float4 b = pow(g_previousResult[id.xy], 1/2.2);
    float4 a = g_output_tonemapped[id.xy];
    float4 b = g_previousResult[id.xy];

    uint3 photon = ReadPhoton_Indexed(id.xy);
    uint pixelMax = max(photon.r, max(photon.g, photon.b));

    float4 delta = abs(a - b) * 256;
    uint diff = uint(dot(delta,1) * 100.0);

    uint2 cellIndex2D = id.xy * g_convergenceCells / g_target_size;
    uint cellIndex = cellIndex2D.y * g_convergenceCells.x + cellIndex2D.x;

    InterlockedAdd(g_convergenceCellStateOut[cellIndex].PixelChange, diff);
    InterlockedMax(g_convergenceCellStateOut[cellIndex].MaxValue, pixelMax);
}


/////////////////////////
// G BUFFER PROCESSING
/////////////////////////

RWTexture2D<float4> g_sourceMipLevelAlbedo;
RWTexture2D<float4> g_sourceMipLevelNormalSlope;
RWTexture2D<float4> g_sourceMipLevelTransmissibility;
RWTexture2D<float4> g_destMipLevelAlbedo;
RWTexture2D<float4> g_destMipLevelNormalSlope;
RWTexture2D<float4> g_destMipLevelTransmissibility;
RWTexture2D<float4> g_destQuadTreeLeaves;

float g_TransmissibilityVariationEpsilon;

float4 DownsampleAlbedo(uint2 id) {
    float4 a = g_sourceMipLevelAlbedo[id + uint2(0,0)];
    float4 b = g_sourceMipLevelAlbedo[id + uint2(1,0)];
    float4 c = g_sourceMipLevelAlbedo[id + uint2(0,1)];
    float4 d = g_sourceMipLevelAlbedo[id + uint2(1,1)];

    return (a+b+c+d)/4;
}

float4 DownsampleTransmissibility(uint2 id) {
    float4 a = g_sourceMipLevelTransmissibility[id + uint2(0,0)];
    float4 b = g_sourceMipLevelTransmissibility[id + uint2(1,0)];
    float4 c = g_sourceMipLevelTransmissibility[id + uint2(0,1)];
    float4 d = g_sourceMipLevelTransmissibility[id + uint2(1,1)];

    float at = 1 / (a.x + 1);
    float bt = 1 / (b.x + 1);
    float ct = 1 / (c.x + 1);
    float dt = 1 / (d.x + 1);

    float average = (a.x*b.x + c.x*d.x + a.x*c.x + b.x*d.x) / 4;
    float minimum = min(min(a.y*b.y, c.y*d.y), min(a.y*c.y, b.y*d.y));

    float sr_avg = sqrt(average);
    float4 variances = float4(a.x,b.x,c.x,d.x) - sr_avg;
    variances *= variances;
    float variance = dot(variances, 0.25);
    float leaf = (variance < g_TransmissibilityVariationEpsilon) ? 1 : 0;

    return float4(average, minimum, leaf, 1);
}

float4 DownsampleNormalSlope(uint2 id) {
    float4 a = g_sourceMipLevelNormalSlope[id + uint2(0,0)];
    float4 b = g_sourceMipLevelNormalSlope[id + uint2(1,0)];
    float4 c = g_sourceMipLevelNormalSlope[id + uint2(0,1)];
    float4 d = g_sourceMipLevelNormalSlope[id + uint2(1,1)];

    return float4(normalize(a.xy + b.xy + c.xy + d.xy), (a.zw + b.zw + c.zw + d.zw) / 4);
}

[numthreads(8,8,1)]
void GenerateGBufferMips (uint3 id : SV_DispatchThreadID) {
    g_destMipLevelAlbedo[id.xy] = DownsampleAlbedo(id.xy * 2);
    g_destMipLevelTransmissibility[id.xy] = DownsampleTransmissibility(id.xy * 2);
    g_destMipLevelNormalSlope[id.xy] = DownsampleNormalSlope(id.xy * 2);
}

void ComputeTransmissibilityVariance(uint2 id) {

    float3 r1 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1,-1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0,-1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1,-1)].x
    );
    float3 r2 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1, 0)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0, 0)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1, 0)].x
    );
    float3 r3 = float3(
        g_sourceMipLevelTransmissibility[id + uint2(-1, 1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 0, 1)].x,
        g_sourceMipLevelTransmissibility[id + uint2( 1, 1)].x
    );

    
    float mean = dot(r1, 1/9.0) + dot(r2, 1/9.0) + dot(r3, 1/9.0);
    
    float3 d1 = r1 - mean;
    float3 d2 = r2 - mean;
    float3 d3 = r3 - mean;

    float variance = sqrt(dot(d1,d1) + dot(d2,d2) + dot(d3,d3)) / 3.0;
    float leaf = (variance < g_TransmissibilityVariationEpsilon) ? 1 : 0;

    float4 newValue = g_sourceMipLevelTransmissibility[id];
    newValue.z = variance;
    newValue.w = leaf;
    g_sourceMipLevelTransmissibility[id] = newValue;
}

[numthreads(8,8,1)]
void ComputeGBufferVariance (uint3 id : SV_DispatchThreadID) {
    ComputeTransmissibilityVariance(id.xy);
}

[numthreads(8,8,1)]
void GenerateGBufferQuadTree (uint3 id : SV_DispatchThreadID) {
    float2 uv = (id.xy + 0.5) / g_target_size;
    for(int i = g_lowest_lod;i >= 0;i--) {
        float4 leaf = g_transmissibility.SampleLevel(samplerg_transmissibility, uv, i);

        if(leaf.w == 1) {
            g_destQuadTreeLeaves[id.xy] = float4(i,0,0,1);
           break;
        }
  }
}
