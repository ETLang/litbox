#include "../Shaders/PhotonerCommon.cginc"

#pragma kernel AnalysisA
#pragma kernel AnalysisB
#pragma kernel AnalysisC
#line 5

Texture2D<float4> _in_albedo;
Texture2D<float4> _in_transmissibility;
Texture2D<float4> _in_normal_roughness;
Texture2D<float4> _in_hdr_forward_a;
Texture2D<float4> _in_hdr_forward_b;
Texture2D<float4> _in_hdr_a;
Texture2D<float4> _in_hdr_b;
Texture2D<float4> _in_hdr_final;
Texture2D<float4> _in_importance;
Texture2D<float4> _in_variance;
Texture2D<float4> _in_previous_analysis;

RWTexture2D<float4> _out_analysis;

float _brightness_threshold;
float _variance_threshold;

[numthreads(NUMTHREADS_2D)]
void AnalysisA(uint3 id : SV_DispatchThreadID) {
    float2 size = TextureSize(_out_analysis);

    if(any(id.xy >= (uint2)size)) { return; }

    float2 uv = (id.xy + 0.5) / size;

    float3 sample_a = _in_hdr_a.SampleLevel(sampler_linear_clamp, uv, 0).rgb;
    float3 sample_b = _in_hdr_b.SampleLevel(sampler_linear_clamp, uv, 0).rgb;

    // Compute full-resolution relative variance
    float mean = (sample_a + sample_b) / 2.0;
    float3 relative_variance = (sample_a - sample_b) * (sample_a - sample_b) / (mean * mean + 1e-5);

    _out_analysis[id.xy] = float4(dot(relative_variance, 1.0/3.0), 0, 0, 1);
}

[numthreads(NUMTHREADS_2D)]
void AnalysisB(uint3 id : SV_DispatchThreadID) {
    // Perform median filter on variance map
}

[numthreads(NUMTHREADS_2D)]
void AnalysisC(uint3 id : SV_DispatchThreadID) {
    // Perform adaptive guided filter on variance map
}