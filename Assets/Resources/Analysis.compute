#include "../Shaders/PhotonerCommon.cginc"

#pragma kernel AnalysisA
#line 5

Texture2D<float4> _in_albedo;
Texture2D<float4> _in_transmissibility;
Texture2D<float4> _in_normal_roughness;
Texture2D<float4> _in_hdr_forward_a;
Texture2D<float4> _in_hdr_forward_b;
Texture2D<float4> _in_hdr_a;
Texture2D<float4> _in_hdr_b;
Texture2D<float4> _in_hdr_final;
Texture2D<float4> _in_importance;
Texture2D<float4> _in_variance;

RWTexture2D<float4> _out_analysis;

float _brightness_threshold;
float _variance_threshold;

[numthreads(NUMTHREADS_2D)]
void AnalysisA(uint3 id : SV_DispatchThreadID) {
    float2 size = TextureSize(_out_analysis);

    if(any(id.xy >= (uint2)size)) { return; }

    float2 uv = (id.xy + 0.5) / size;

    float variance = _in_variance.SampleLevel(sampler_linear_clamp, uv, 0).x;
    float importance = _in_importance.SampleLevel(sampler_linear_clamp, uv, 0).x;

   // float result = variance / importance;
   // float result = variance * (1-saturate(importance / _brightness_threshold));
    float brightnessCriterion = 1-saturate(importance / _brightness_threshold);

    float varianceCriterion = variance / _variance_threshold;

    float result = brightnessCriterion;

    _out_analysis[id.xy] = float4(0, result, 0, 1);

    // POWER HEURISTIC
    // (NfPf)^2 / ((NfPf)^2 + (NbPb)^2)

    // Nf = RaysEmitted
    // Pf = energy per ray
    // Nb = w*h*samples
    // Pb = 
}